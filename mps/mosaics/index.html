<!DOCTYPE html>
<html lang="en">


<!-- Mirrored from courses.engr.illinois.edu/cs225/sp2019/mps/mosaics/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 09 May 2019 18:15:33 GMT -->
<head>
    <meta charset="UTF-8">
    <title>CS 225 | mp_mosaics</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="base_url" content="/cs225/sp2019">

    <link rel="apple-touch-icon" sizes="57x57" href="../../static/img/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../static/img/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../static/img/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../static/img/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../static/img/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../static/img/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../../static/img/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../../static/img/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../../static/img/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="../../static/img/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../static/img/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="../../static/img/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../static/img/favicon-16x16.png">
<link rel="manifest" href="../../static/img/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="../../static/img/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">


    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css">

<link rel="stylesheet" href="../../static/css/main.css">
<link rel="stylesheet" href="../../static/css/github-highlighting.css">

<script src="https://code.jquery.com/jquery-3.4.0.min.js" integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script>
<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            TeX: {
                extensions: [ "AMSmath.js", "AMSsymbols.js" ]
            },
            tex2jax: {
                inlineMath: [['\\(','\\)'], ['$$','$$']],
                displayMath: [['\\[','\\]']]
            },
        });
</script>

<style>
    svg.graph {
        overflow: visible;
        margin-left: auto;
        margin-right: auto;
        margin-bottom: 10px;
        display: block;
        max-width: 95%;
    }
</style>

<style>
  /* Main items  */
  .main-item {
    border-top-left-radius: calc(1rem - 1px);
    border-top-right-radius: calc(1rem - 1px);
    border-bottom-left-radius: calc(1rem - 1px);
    border-bottom-right-radius: calc(1rem - 1px);
    background-size: cover;
    padding: 10px
  }

  .main-item-mp {
    background-image: url('../../assets/covers/default_mp.svg')
  }

  .main-item-lab {
    background-image: url('../../assets/covers/default_lab.svg')
  }

  .main-item-note {
    background-image: url('../../assets/covers/notes.svg')
  }

  .main-item-body {
    width: 320px;
    height: 180px;
    padding: 20px;

    display: flex;
    border: none !important;
    flex-direction: column;
    justify-content: center;
    background-color: rgba(255, 255, 255, 0.91) !important;
  }

  .main-item-body:hover {
    background-color: rgba(255, 255, 255, 0) !important;
    background: transparent;
    border: transparent;
  }

  .main-item-body:hover * {
    -webkit-text-fill-color: white !important;
    -webkit-background-clip: none !important;
  }

  .main-item-text {
    -webkit-text-fill-color: transparent;
    -webkit-background-clip: text;
    background-size: cover;
  }

  .main-item-text-mp {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/default_mp.svg')
  }

  .main-item-text-lab {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/default_lab.svg')
  }

  .main-item-text-note {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/notes.svg')
  }
</style>

</head>
<body class="mb-3">
<nav class="navbar navbar-expand-md navbar-dark bg-dark">
    <a class="navbar-brand mr-0 mr-md-2" href="../../index.html">
        <img src="../../static/img/UIUC_logo.png" alt="UIUC Logo" width="24" height="32" class="d-inline-block align-top mr-2">
        CS 225
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbar">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item ">
                <a class="nav-link" href="../../pages/lectures.html">Lectures</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../assignments/index.html">Assignments</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../exams/index.html">Exams</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../notes/index.html">Notes</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../pages/resources.html">Resources</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../pages/course_info.html">Course Info</a>
            </li>
        </ul>
    </div>
</nav>

<style>
    @media (min-width: 768px) {
        #toc {
            display: block!important;
            top: 1rem;
        }
    }
</style>

<!-- Main jumbotron for a primary marketing message or call to action -->
<div class="jumbotron jumbotron-fluid text-light" style="background-image:url('../../assets/covers/default_mp.svg');">
    <div class="container">
        <div class="d-md-flex justify-content-between">
            <div>
                <h1>mp_mosaics</h1>
                <h2 class="h5">Monstrous Mosaics</h2>
            </div>
            <div class="d-flex flex-column justify-content-start align-items-md-end">
                
                <small>Extra credit: <span>Mar 25, 23:59 PM</span></small>
                
                <small>Due: <span>Apr 01, 23:59 PM</span></small>
                <div class="btn-group mt-2" style="overflow-x: auto;">
                    <a class="btn btn-light" href="../../doxygen/mp_mosaics/annotated.html" role="button">Doxygen</a>
                    
                    
                    
                </div>
            </div>
        </div>
    </div>
</div>


<div class="container-fluid">
    <div class="row">
        <div class="col-12 col-md-3 col-xl-2 px-3 pb-3">
            <button class="btn btn-outline-secondary d-inline-block d-md-none" type="button" data-toggle="collapse" data-target="#toc" aria-expanded="false" aria-controls="toc">
                <i class="fa fa-bars mr-1"></i> Table of Contents
            </button>
            <nav id="toc" class="sticky-top collapse"></nav>
        </div>
        <main class="col-12 col-md-9 col-xl-10">
            
<div class="alert alert-success" role="alert">
  <p><i class="fa fa-location-arrow"></i> 
<strong>Partner MP</strong>
mp_mosaics is a <strong>partner MP</strong>!</p>

  <ul>
    <li>Part 1 and Part 2 of this MP can be completed with a partner!</li>
    <li>The creative “Part 3” must be completed by yourself and must be unique (and different from your partner’s work).</li>
  </ul>

  <p>You should denote who you work with in the PARTNERS.txt file in mp_mosaics.  If you worked alone, include only your NetID in PARTNERS.txt.</p>
</div>

<h2 id="goals-and-overview">Goals and Overview</h2>

<p>In this MP, you will:</p>

<ul>
  <li>learn about <a href="../../notes/kd-tree/index.html">k-d trees</a></li>
  <li>implement and use a <a href="https://en.wikipedia.org/wiki/Nearest_neighbor_search">nearest neighbor search (NNS)</a> algorithm</li>
  <li>practice using <a href="https://en.wikipedia.org/wiki/Template_(programming)">templates</a></li>
  <li>practice <a href="https://en.wikipedia.org/wiki/Const_correctness"><code class="highlighter-rouge">const</code>-correctness</a></li>
  <li>use your knowledge to make a useful application</li>
</ul>

<h2 id="videos">Videos</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=T9h2KKJ_Pl8">k-d tree : 2-D example</a></li>
  <li><a href="https://www.youtube.com/watch?v=aOhyCdxGJvY">(partition based) Quick Select</a></li>
  <li><a href="https://www.youtube.com/watch?v=2SbVSxWGtpI">findNearestNeighbor - Part 1: Explanation</a></li>
  <li><a href="https://www.youtube.com/watch?v=dyU2WyjhyLM">findNearestNeighbor - Part 2: Walkthrough</a></li>
</ul>

<h2 id="checking-out-your-code">Checking Out Your Code</h2>

<p>From your CS 225 git directory, run the following on EWS:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git pull
git fetch release
git merge release/mp_mosaics -m "Merging initial mp_mosaics files"
</code></pre></div></div>

<p>If you’re on your own machine, you may need to run:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git pull
git fetch release
git merge --allow-unrelated-histories release/mp_mosaics -m "Merging initial mp_mosaics files"
</code></pre></div></div>

<p>Upon a successful merge, your mp_mosaics files are now in your <code class="highlighter-rouge">mp_mosaics</code> directory.</p>

<div class="alert alert-success" role="alert">
  <p><i class="fa fa-location-arrow"></i> 
<strong>Doxygen</strong></p>

  <p>You can see all of the <a href="../../doxygen/mp_mosaics/todo.html">required functions</a> on the TODO page on the
Doxygen for this MP.</p>

  <p>A list of relevant files is <a href="../../doxygen/mp_mosaics/files.html">here</a>.</p>
</div>

<h2 id="background-photomosaics">Background: PhotoMosaics</h2>

<p>A PhotoMosaic is a picture created by taking some source picture, dividing it
up into rectangular sections, and replacing each section with a small thumbnail
image whose color closely approximates the color of the section it replaces.
Viewing the PhotoMosaic at low magnification, the individual pixels appear as
the source image, while a closer examination reveals that the image is made up
of many smaller tile images.</p>

<div class="row">
<div class="col">
    <figure class="figure">
	<a href="../../assets/assignments/mps/mp_mosaics/quad_mosaic_thum.png">
        <img class="img-fluid" src="../../assets/assignments/mps/mp_mosaics/quad_mosaic_thum.png" />
	</a>
        <figcaption class="figure-caption">Click for the (rather large) full-size mosaic</figcaption>
    </figure>
</div>
</div>

<p>For this project you will be implementing parts of a PhotoMosaic generator.
Specifically your code will be responsible for deciding how to map tile images
to the rectangular sections of pixels in the source image. Selecting the
appropriate tile image is supported by a data structure called a <script type="math/tex">k</script>-d tree
which we will describe in the next section. The pool of tile images are
specified by a local directory of images. We provide the code to create the
TileImage pool and the code to create the mosaic picture from a tiled source
image.</p>

<p>A final thing to note is that the HSL color space does a poor job on finding the
best tiled source image.  Consider a nearly white pixel with <code class="highlighter-rouge">l=99%</code>: the pixel
<code class="highlighter-rouge">(h=0, s=100%, l=99%)</code> will appear nearly just as white as the pixel <code class="highlighter-rouge">(h=180, s=0%, l=99%)</code>
even though the pixels are very far apart.  Instead, we have modified the
<code class="highlighter-rouge">HSLAPixel</code> into a <code class="highlighter-rouge">LUVAPixel</code> using a perceptually uniform color space.  You can read
about the <a href="https://en.wikipedia.org/wiki/CIELUV">LUV color space on Wikipedia</a> to find out more.</p>

<h2 id="background-k-d-trees">Background: K-d trees</h2>

<p>Binary Search Trees are linear data structures that support the Dictionary ADT
operations (<code class="highlighter-rouge">insert</code>, <code class="highlighter-rouge">find</code>, <code class="highlighter-rouge">remove</code>). They also support nearest neighbor
search: If you have a binary search tree, given a key that may or may not be in
the tree, you can find the closest key that is in the tree. To do so, you just
recursively walk down the tree, as in <code class="highlighter-rouge">find</code>, keeping track of the closest node
found:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">K</span> <span class="n">BST</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span><span class="n">V</span><span class="o">&gt;::</span><span class="n">findNearestNeighbor</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span> <span class="n">croot</span><span class="p">,</span> <span class="n">K</span> <span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Look in the left or right subtree depending on whether target is smaller or larger than our current root</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="o">&lt;</span> <span class="n">croot</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// if we have no child in the correct direction, our root must be the closest</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">croot</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">croot</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
        <span class="n">childResult</span> <span class="o">=</span> <span class="n">findNearestNeighbor</span><span class="p">(</span><span class="n">croot</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">croot</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">croot</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
        <span class="n">childResult</span> <span class="o">=</span> <span class="n">findNearestNeighbor</span><span class="p">(</span><span class="n">croot</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Calculate closest descendent node's distance to the target</span>
    <span class="n">childDistance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">childResult</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>

    <span class="c1">// Find the distance of this node to the target</span>
    <span class="n">currDistance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">croot</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>

    <span class="c1">// If the root node is closer, return it, otherwise return the closer child</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">currDistance</span> <span class="o">&lt;</span> <span class="n">childDistance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">croot</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">childResult</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A <script type="math/tex">k</script>-d tree is a generalization of a Binary Search Tree that supports
nearest neighbor search in higher numbers of dimensions — for example, with
2-D or 3-D points, instead of only 1-D keys. A 1-D-tree (a <script type="math/tex">k</script>-d tree with
<script type="math/tex">k = 1</script>) is simply a binary search tree. For this MP, you will be creating a
photomosaic, which requires that given a region on our original image, we can
determine which of our available images best fills that region.  If we use the
average color of regions and tile-images, this can be determined by finding the
nearest colored tile image to a given region. If we treat colors as <script type="math/tex">(L, U,
V)</script> points in 3-D space, we can solve this problem with a 3-D tree.</p>

<p>More formally, a <script type="math/tex">k</script>-d tree is special purpose data structure used to
organize elements that can be described by locations in <script type="math/tex">k</script>-dimensional
space. It is considered a space-partitioning data structure because it
recursively subdivides a space into two convex sets. These sets are rectangular
regions of the space called <a href="https://en.wikipedia.org/wiki/Hyperrectangle">hyperrectangles</a>. <script type="math/tex">k</script>-d
trees are particularly useful for implementing nearest neighbor search, which
is an optimization problem for finding the closest element in <script type="math/tex">k</script>-dimensional
space.</p>

<p>A <script type="math/tex">k</script>-d tree is a rooted binary tree. Each node in the tree represents a
point in <script type="math/tex">k</script>-d-space, as well as a line (hyperplane) defined by one dimension
of this point, which divides this space into two regions (hyperrectangles). At
each level in the tree, a different dimension is used to decide the direction
of the splitting line (hyperplane). An element is selected to define the
splitting line by its coordinate value for the current dimension. This element
should be the median of all the points in this part of the tree, taken over the
current dimension. A node is then created for this element in the tree and its
children are created recursively using the same process, which repeats until no
elements remain in the region (hyperrectangle). The splitting dimension at any
level of the tree can be selected to find the best partition of the data. For
our purposes, we will change dimension cyclically, in order (for <script type="math/tex">k = 3</script>, we
will use dimensions <script type="math/tex">0, 1, 2, 0, 1, 2, 0, \ldots</script>).</p>

<div class="row">
<div class="col">
    <figure class="figure">
        <img class="img-fluid" src="../../assets/assignments/mps/mp_mosaics/kdtree-tree.svg" />
        <figcaption class="figure-caption">Figure 1: the tree on the left is an example 2-dimensional $$k$$-d tree and the diagram on the right shows how the space is partitioned by the splitting planes into hyperrectangles for that tree. (Note that our implementation will make a slightly different tree from this set of points because of the way we will define the median.)</figcaption>
    </figure>
</div>
</div>

<p><script type="math/tex">k</script>-d trees are particularly useful for searching points in Euclidean space.
Perhaps the most common use of a <script type="math/tex">k</script>-d tree is to allow for fast search for
the nearest neighbor of a query point, among the points in the tree. That is,
given an arbitrary point in <script type="math/tex">k</script>-dimensional space, find the point in the tree
which is nearest to this point. The search algorithm is defined in detail
below.</p>

<p>For this MP, we will be using a 3-D tree (a 3-dimensional <script type="math/tex">k</script>-d tree) to find
the closest average color of <code class="highlighter-rouge">TileImage</code>s to the average color of pixel
sections in the source image. With the pool of average colors organized in a
<script type="math/tex">k</script>-d tree, we can search for the best tile to match the average color of
every region in the input image, and use it to create a PhotoMosaic!</p>

<h2 id="requirements">Requirements</h2>

<p>These are strict requirements that apply to <strong>both</strong> parts of the MP. Failure
to follow these requirements may result in a failing grade on the MP.</p>
<ul>
  <li>You must name all files, public functions, public member variables (if any
exist), and executables <strong>exactly</strong> as we specify in this document.</li>
  <li>Your code must produce the <strong>exact</strong> output that we specify: nothing more,
nothing less. Output includes standard and error output and files such as
images.</li>
  <li>Your code must compile on the EWS machines using <strong>clang++</strong>. Being able to
compile on a different machine is <strong>not</strong> sufficient.</li>
  <li>Your code must be submitted correctly by the <strong>due date and time</strong>. Late work
is not accepted.</li>
  <li>Your code must not have any memory errors or leaks for full credit. Valgrind
tests will be performed separately from the functionality tests.</li>
  <li>Your public function signatures must match ours <strong>exactly</strong> for full credit.
If using different signatures prevents compilation, you will receive a zero.
Tests for <code class="highlighter-rouge">const</code>-correctness may be performed separately from the other
tests (if applicable).</li>
</ul>

<h2 id="assignment-description">Assignment Description</h2>

<p>We have provided the bulk of the code to support the generation of
PhotoMosaics. There is one critical component that is missing: the
<code class="highlighter-rouge">KDTileMapper</code>. This class is responsible for deciding which <code class="highlighter-rouge">TileImage</code>s to
use for each region of the original image. In order to make this decision it
must be able to figure out which <code class="highlighter-rouge">TileImage</code> has the closest average color to
the average color of that region. A data structure called a <script type="math/tex">k</script>-d tree is
used to find the nearest neighbor of a point in <script type="math/tex">k</script>-dimensional space.</p>

<p>This assignment is broken up into the following two parts:</p>

<ul>
  <li><a href="#part1">Part 1</a> — the <code class="highlighter-rouge">KDTree</code> class.</li>
  <li><a href="#part2">Part 2</a> — the <code class="highlighter-rouge">mapTiles</code> function.</li>
</ul>

<p>As usual, we recommend implementing, compiling, and testing the functions in
<a href="#part1">Part 1</a> before starting <a href="#part2">Part 2</a>.</p>

<h2 id="part1">Part 1</h2>

<p>For the first part of mp_mosaics, you will implement a generic <code class="highlighter-rouge">KDTree</code> class that
can be used to organize points in <script type="math/tex">k</script>-dimensional space, for any integer <script type="math/tex">k > 0</script>.</p>

<h3 id="the-kdtree-class">The <code class="highlighter-rouge">KDTree</code> class</h3>

<p>Although we will only be using a 3-D tree, we want you to create a more general
data structure that will work with any positive non-zero number of dimensions.
Therefore, you will be creating a templated class where the template parameter
is an integer, specifying the number of dimensions. We have provided the
skeleton of this class, but it is your assignment to implement the member
functions and any helper functions you need.</p>

<p>A <script type="math/tex">k</script>-d tree is constructed with <code class="highlighter-rouge">Point</code>s in <script type="math/tex">k</script>-dimensional space. To
support this, we have provided a templated <code class="highlighter-rouge">Point</code> class, which takes the same
integer template parameter as the <script type="math/tex">k</script>-d tree.</p>

<p>In this part of assignment we ask you to implement all of the following member
functions.</p>

<h3 id="implementing-smallerdimval">Implementing <code class="highlighter-rouge">smallerDimVal</code></h3>

<p>Please see the Doxygen for <a href="../../doxygen/mp_mosaics/classKDTree.html#a121c4423d7b9b7188e33c70466f36362"><code class="highlighter-rouge">smallerDimVal</code></a>.</p>

<p>This function should take in two templatized <code class="highlighter-rouge">Point</code>s and a dimension and
return a boolean value representing whether or not the first <code class="highlighter-rouge">Point</code> has a
smaller value than the second in the dimension specified. That is, if the
dimension passed in is <script type="math/tex">k</script>, then this should be <code class="highlighter-rouge">true</code> if the coordinate of
the first point at <script type="math/tex">k</script> is less than the coordinate of the second point at
<script type="math/tex">k</script>. <strong>If there is a tie, break it using <code class="highlighter-rouge">Point</code>’s <code class="highlighter-rouge">operator&lt;</code>. For
example:</strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Point</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">Point</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">smallerDimVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// should print true,</span>
                                        <span class="c1">//    since 1 &lt; 3</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">smallerDimVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// should print false,</span>
                                        <span class="c1">//    since 3 &gt; 1</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">smallerDimVal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// should print true,</span>
                                        <span class="c1">//    since a &lt; b according to operator&lt;,</span>
</code></pre></div></div>

<h3 id="implementing-shouldreplace">Implementing <code class="highlighter-rouge">shouldReplace</code></h3>

<p>Please see the Doxygen for <a href="../../doxygen/mp_mosaics/classKDTree.html#a4ee8a8bd441a6cef3876056c4540defc"><code class="highlighter-rouge">shouldReplace</code></a>.</p>

<p>This function should take three templated <code class="highlighter-rouge">Point</code>s: <code class="highlighter-rouge">target</code>, <code class="highlighter-rouge">currentBest</code>,
and <code class="highlighter-rouge">potential</code>. This should return <code class="highlighter-rouge">true</code> if <code class="highlighter-rouge">potential</code> is closer (i.e., has
a smaller distance) to <code class="highlighter-rouge">target</code> than <code class="highlighter-rouge">currentBest</code> (with a tie being broken by
the <code class="highlighter-rouge">operator&lt;</code> in the <code class="highlighter-rouge">Point</code> class: <code class="highlighter-rouge">potential &lt; currentBest</code>). The Euclidean
distance between two <script type="math/tex">k</script>-dimensional points, <script type="math/tex">P(p_1, p_2, \ldots, p_k)</script>
and <script type="math/tex">Q(q_1, q_2, \ldots, q_k)</script>, is the square root of the sum of squares
of the differences in each dimension:</p>

<div>

\[

    \sqrt{(p_1 - q_1)^2 + (p_2 - q_2)^2 + \cdots + (p_k - q_k)^2} =
    \sqrt{\sum_{i = 1}^k (p_i - q_i)^2}
\]

</div>

<p>Note that minimizing the distance is the same as minimizing squared-distance,
so you can avoid invoking the square root, and just compare squared distances
throughout your code:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Point</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">target</span>        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="n">Point</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">currentBest1</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">Point</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">possibleBest1</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">Point</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">currentBest2</span>  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">Point</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">possibleBest2</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">Point</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">currentBest3</span>  <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="n">Point</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">possibleBest3</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shouldReplace</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">currentBest1</span><span class="p">,</span> <span class="n">possibleBest1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// should print true</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shouldReplace</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">currentBest2</span><span class="p">,</span> <span class="n">possibleBest2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// should print false</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shouldReplace</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">currentBest3</span><span class="p">,</span> <span class="n">possibleBest3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// based on operator&lt;, this should be false!!!</span>
</code></pre></div></div>

<h3 id="implementing-the-kdtree-constructor">Implementing the <code class="highlighter-rouge">KDTree</code> Constructor</h3>

<p>Please see the Doxygen for the <a href="../../doxygen/mp_mosaics/classKDTree.html#a2b29b6675805718d7963cb187bc6d602"><code class="highlighter-rouge">KDTree</code> constructor</a>.</p>

<p>This takes a single parameter, a reference to a constant <a href="http://en.cppreference.com/w/cpp/container/vector"><code class="highlighter-rouge">std::vector</code></a> of
<code class="highlighter-rouge">Point&lt;Dim&gt;</code>s. The constructor should build the tree using recursive helper
function(s).</p>

<p>Just like there is a way to represent a balanced binary search tree using a
specially sorted vector of numbers (how?), we can specially sort a vector of
points in such a way that it represents a <script type="math/tex">k</script>-d tree. More specifically, in
the <code class="highlighter-rouge">KDTree</code> constructor, we are interested in first copying the input list of points
into a points vector, sorting this vector so it represents a <script type="math/tex">k</script>-d
tree, and building the actual <script type="math/tex">k</script>-d tree along while we sort.</p>

<div class="alert alert-success" role="alert">
  <p><i class="fa fa-location-arrow"></i> 
<strong>Definition</strong>
A rooted binary tree <script type="math/tex">T</script> is a <script type="math/tex">k</script>-d tree if:</p>

  <ul>
    <li><script type="math/tex">T</script> is empty, OR</li>
    <li><script type="math/tex">T</script> consists of
      <ul>
        <li>A <script type="math/tex">k</script>-dimensional point <script type="math/tex">r</script> that represents the root of the tree.</li>
        <li>A splitting dimension <script type="math/tex">d</script></li>
        <li>Two <script type="math/tex">k</script>-d tree subtrees <script type="math/tex">T_L</script> and <script type="math/tex">T_R</script> of splitting dimension
<script type="math/tex">(d+1) \bmod k</script> such that
          <ul>
            <li>if <script type="math/tex">v</script> is an element in <script type="math/tex">T_L</script>, then <script type="math/tex">v_d \le r_d</script></li>
            <li>if <script type="math/tex">v</script> is an element in <script type="math/tex">T_R</script>, then <script type="math/tex">v_d \ge r_d</script></li>
          </ul>
        </li>
      </ul>

      <p>where <script type="math/tex">v_d</script> and <script type="math/tex">r_d</script> are the <script type="math/tex">d</script>th components of the points <script type="math/tex">v</script>
  and <script type="math/tex">r</script>. This property of <script type="math/tex">k</script>-d trees is called its <strong>recursive
  property</strong> because, similar to binary search trees, <script type="math/tex">k</script>-d trees are
  recursive data structures.</p>

      <p>Furthermore, in our implementation, <script type="math/tex">r</script> is the <strong>median</strong> of all the
  points (defined below) in <script type="math/tex">T</script> in dimension <script type="math/tex">d</script>.</p>
    </li>
  </ul>

  <p>We define the <strong>median</strong> of the points across a splitting dimension <script type="math/tex">d</script> to be
the <script type="math/tex">\left\lceil\frac{n}{2}\right\rceil</script> smallest element in a sorted
list using <script type="math/tex">d</script>; in other words, it is the <strong>middle-most element</strong> of a (odd
length) sorted list containing <script type="math/tex">n</script> elements. For the general case of the
median of a vector between zero-based indices <script type="math/tex">a</script> and <script type="math/tex">b</script>, the median would
be the element located at <script type="math/tex">\left\lfloor\frac{a+b}{2}\right\rfloor</script>.</p>
</div>

<p>The <strong>median index</strong> of <script type="math/tex">n</script> nodes is calculated as the cell
<script type="math/tex">\left\lfloor\frac{n-1}{2}\right\rfloor</script>. That is, the middle index is
selected if there are an odd number of items, and the item before the middle if
there are an even number of items. <strong>If there are ties (two points have equal
value along a dimension), they must be decided using the <code class="highlighter-rouge">Point</code> class’s
<code class="highlighter-rouge">operator&lt;</code>.</strong> Although this is arbitrary and doesn’t affect the functionality
of the <script type="math/tex">k</script>-d tree, it is required to be able to grade your code.</p>

<p>The <script type="math/tex">k</script>-d tree construction algorithm is defined recursively as follows for a
vector of points between indices <script type="math/tex">a</script> and <script type="math/tex">b</script> at splitting dimension <script type="math/tex">d</script>:</p>

<ol>
  <li>Find the median of points with respect to dimension <script type="math/tex">d</script>.</li>
  <li>Place the median point <script type="math/tex">r</script> at index <script type="math/tex">m =
\left\lfloor\frac{a+b}{2}\right\rfloor</script> such that
    <ul>
      <li>if point <script type="math/tex">v</script> is between indices <script type="math/tex">a</script> and <script type="math/tex">m-1</script>, then <script type="math/tex">v_d \leq r_d</script></li>
      <li>if point <script type="math/tex">v</script> is between indices <script type="math/tex">m+1</script> and <script type="math/tex">b</script>, then <script type="math/tex">v_d \geq r_d</script></li>
    </ul>
  </li>
  <li>Create a subroot based on the median and then recurse on the indices between
<script type="math/tex">a</script> though <script type="math/tex">m-1</script> for its left subtree, and <script type="math/tex">m+1</script> through <script type="math/tex">b</script> for its right
subtree, using splitting dimension <script type="math/tex">(d+1) \bmod k</script>.</li>
</ol>

<p>To satisfy steps 1 and 2 of the <script type="math/tex">k</script>-d tree construction algorithm, we
recommend finding the median of the vector of points using <strong>quickselect</strong>.
The <a href="https://en.wikipedia.org/wiki/Quickselect">quickselect algorithm</a> allows you to find the median of
the vector while achieving the constraints mentioned in step 2. We recommend
that you first understand the algorithm and then write your own code from
scratch to implement it. This will make debugging far, far easier.</p>

<div class="alert alert-danger" role="alert">
  <p><i class="fas fa-radiation-alt"></i> 
Note that you are <strong>not</strong> allowed to use any standard library functions to sort
the data or find the median of the <code class="highlighter-rouge">vector</code>. This includes functions in
<code class="highlighter-rouge">&lt;algorithm&gt;</code> like <code class="highlighter-rouge">std::sort</code> and <code class="highlighter-rouge">std::nth_element</code>. For a complete list see
the functions in <code class="highlighter-rouge">mp_mosaics_provided/no_sort.h</code>.</p>
</div>

<div class="alert alert-info" role="alert">
  <p><i class="fa fa-info-circle"></i> 
Here’s an example of how the algorithm works on the array below.</p>

  <style type="text/css" scoped="">
.mp_mosaics-table {
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 10px;
    font-size: larger;
}
.mp_mosaics-table th, .mp_mosaics-table td {
    text-align: center;
}
.mp_mosaics-table td {
    width: 4em;
    padding: 2px 6px;
    border: 1px solid;
}
.mp_mosaics-table td.blank {
}
.mp_mosaics-table td.level-0 {
    font-weight: bold;
    background-color: #FFCE66;
}
.mp_mosaics-table td.level-1 {
    font-weight: bold;
    background-color: #79E0FF;
}
.mp_mosaics-table td.level-2 {
    font-weight: bold;
    background-color: #FAA23E;
}
.mp_mosaics-table td.level-3 {
    font-weight: bold;
    background-color: #82CAEF;
}
</style>

  <table class="mp_mosaics-table">
    <thead>
        <tr>
            <th>0</th>
            <th>1</th>
            <th>2</th>
            <th>3</th>
            <th>4</th>
            <th>5</th>
            <th>6</th>
            <th>7</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>(3, 2)</td>
            <td>(5, 8)</td>
            <td>(6, 1)</td>
            <td>(4, 4)</td>
            <td>(9, 0)</td>
            <td>(1, 1)</td>
            <td>(2, 2)</td>
            <td>(8, 7)</td>
        </tr>
    </tbody>
</table>

  <p>With respect to splitting dimension <script type="math/tex">0</script>, we would now find the median of
these points, and place it in index
<script type="math/tex">\left\lfloor\frac{0+7}{2}\right\rfloor = 3</script>. (This is step 1 and 2 of
the algorithm.) We could achieve this using quickselect. This yields the
following array.</p>

  <table class="mp_mosaics-table">
    <thead>
        <tr>
            <th>0</th>
            <th>1</th>
            <th>2</th>
            <th>3</th>
            <th>4</th>
            <th>5</th>
            <th>6</th>
            <th>7</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="blank"></td>
            <td class="blank"></td>
            <td class="blank"></td>
            <td class="level-0">(4, 4)</td>
            <td class="blank"></td>
            <td class="blank"></td>
            <td class="blank"></td>
            <td class="blank"></td>
        </tr>
    </tbody>
</table>

  <p>What’s important to note is that the two sublists contained in indices 0–2 and
4–7, <script type="math/tex">L_1</script> and <script type="math/tex">L_2</script> respectively, achieve the constraint mentioned in
step 2 of the <script type="math/tex">k</script>-d tree construction algorithm. (See above.) Hence, the full
list may appear like this:</p>

  <table class="mp_mosaics-table">
    <thead>
        <tr>
            <th>0</th>
            <th>1</th>
            <th>2</th>
            <th>3</th>
            <th>4</th>
            <th>5</th>
            <th>6</th>
            <th>7</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="blank">(1, 1)</td>
            <td class="blank">(3, 2)</td>
            <td class="blank">(2, 2)</td>
            <td class="level-0">(4, 4)</td>
            <td class="blank">(6, 1)</td>
            <td class="blank">(5, 8)</td>
            <td class="blank">(9, 0)</td>
            <td class="blank">(8, 7)</td>
        </tr>
    </tbody>
</table>

  <p>When we recursively call the algorithm on <script type="math/tex">L_1</script> and <script type="math/tex">L_2</script> using splitting
dimension <script type="math/tex">1</script> (step 3), we achieve the following ordering. (Follow along this
example using pen and paper.)</p>

  <table class="mp_mosaics-table">
    <thead>
        <tr>
            <th>0</th>
            <th>1</th>
            <th>2</th>
            <th>3</th>
            <th>4</th>
            <th>5</th>
            <th>6</th>
            <th>7</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class="level-2">(1, 1)</td>
            <td class="level-1">(2, 2)</td>
            <td class="level-2">(3, 2)</td>
            <td class="level-0">(4, 4)</td>
            <td class="level-2">(9, 0)</td>
            <td class="level-1">(6, 1)</td>
            <td class="level-2">(5, 8)</td>
            <td class="level-3">(8, 7)</td>
        </tr>
    </tbody>
</table>

  <p>This, likewise, represents the following <script type="math/tex">k</script>-d tree:</p>

  <script type="x/graph">
graph G {
    graph [ordering="out"];

    node [style=filled, fillcolor="#FFCE66"];
    "(4, 4)";
    node [style=filled, fillcolor="#79E0FF"];
    "(2, 2)";
    "(6, 1)";
    node [style=filled, fillcolor="#FAA23E"];
    "(1, 1)";
    "(3, 2)";
    "(9, 0)";
    "(5, 8)";
    node [style=filled, fillcolor="#82CAEF"];
    "(8, 7)";
    node[label="",width=.1,style=invisible]

    i2 [width=1];
    i4 [label="(0, 0)"];

    "(4, 4)" -- "(2, 2)";
        "(2, 2)" -- "(1, 1)";
        "(2, 2)" -- i1 [style=invisible];
        "(2, 2)" -- "(3, 2)";
    "(4, 4)" -- i2 [style=invisible];
    "(4, 4)" -- "(6, 1)";
        "(6, 1)" -- "(9, 0)";
        "(6, 1)" -- i3 [style=invisible];
        "(6, 1)" -- "(5, 8)";
            "(5, 8)" -- i4 [style=invisible];
            "(5, 8)" -- "(8, 7)";
}
</script>

  <p>The orange colors represent nodes that were split across the 0th dimension,
while the blue colors represent nodes that were split across the 1st dimension.
(Why is <script type="math/tex">% <![CDATA[
(2, 2) < (3, 2) %]]></script> with respect to the 1st dimension?)</p>
</div>

<h3 id="implementing-findnearestneighbor">Implementing <code class="highlighter-rouge">findNearestNeighbor</code></h3>

<p>Please see the Doxygen for <a href="../../doxygen/mp_mosaics/classKDTree.html#af16be75e9218a0da8c12c21eb10b08d3"><code class="highlighter-rouge">findNearestNeighbor</code></a>.</p>

<p>This function takes a reference to a template parameter <code class="highlighter-rouge">Point</code> and returns the
<code class="highlighter-rouge">Point</code> closest to it in the tree. We are defining closest here to be the
minimum Euclidean distance between elements. Again, <strong>if there are ties (this
time in distance), they must be decided using the <code class="highlighter-rouge">Point</code> class’s
<code class="highlighter-rouge">operator&lt;</code></strong>.</p>

<p>The <code class="highlighter-rouge">findNearestNeighbor</code> search is done in two steps: a search to find the
smallest hyperrectangle that contains the target element, and then a back
traversal to see if any other hyperrectangle could contain a closer point,
which may be a point with smaller distance or a point with equal distance, but
a “smaller” point (as defined by <code class="highlighter-rouge">operator&lt;</code> in the <code class="highlighter-rouge">Point</code> class).</p>

<p>In the first step, you must recursively traverse down the tree, at each level
choosing the subtree which represents the region containing the search element.
(Remember that the criteria for which you choose to recurse left or recurse
right depends on the splitting dimension of the current level.) When you reach
the lowest bounding hyperrectangle, then the corresponding node is effectively
the “current best” neighbor. Note that this search is similar to a binary
search algorithm, except with the possibility of a tie across a level’s
splitting dimension.</p>

<p>At then end of first step of the search, we start traversing back up the
<script type="math/tex">k</script>-d tree to the parent node. We now want to find better matches that exist
outside of the containing hyperrectangle. The current best distance defines a
radius which contains the nearest neighbor. During the back-traversal (i.e.,
stepping out of the recursive calls), you must first check if the distance to
the parent node is less than the current radius. If so, then that distance now
defines the radius, and we replace the “current best” match.</p>

<p>Next, it is necessary to check to see if the current splitting plane’s distance
from search node is within the current radius. If so, then the opposite subtree
could contain a closer node, and must also be searched recursively.</p>

<p>During the back-traversal, it is important to only check the subtrees that are
within the current radius, or else the efficiency of the <script type="math/tex">k</script>-d tree is lost.
If the distance from the search node to the splitting plane is greater than the
current radius, then there cannot possibly be a better nearest neighbor in the
subtree, so the subtree can be skipped entirely.</p>

<p>Here is a reference we found quite useful in writing our <script type="math/tex">k</script>-d tree: <a href="../../assets/assignments/mps/mp_mosaics/moore-tutorial.pdf">Andrew
Moore’s Kd-tree Tutorial</a>.</p>

<p>You can assume that <code class="highlighter-rouge">findNearestNeighbor</code> will only be called on a valid
<script type="math/tex">k</script>-d tree.</p>

<p>Here is an example:</p>

<div class="alert alert-info" role="alert">
  <p><i class="fa fa-info-circle"></i> 
<strong>Example</strong></p>

  <p>Suppose we have the same <script type="math/tex">k</script>-d tree as in Figure 1 and that the target point
(in red) is <script type="math/tex">(6,3)</script>, as shown in the figure below. We wish to find the point
in the <script type="math/tex">k</script>-d that is closest to the target; i.e., to determine which of the
black points is closest to the red point.</p>

  <div class="row">
<div class="col">
    <figure class="figure">
        <img class="img-fluid" src="../../assets/assignments/mps/mp_mosaics/kdtree-step00.svg" />

    </figure>
</div>
</div>

  <p>To start the search, we begin a depth-first search to find the leaf node within
the same splitting plane as the target node. At the root of the tree, the node
is defined by the point <script type="math/tex">(7,2)</script>, with the splitting plane based on the first
coordinate. Since <script type="math/tex">% <![CDATA[
6 < 7 %]]></script> (using the target coordinate’s first dimension) we
search the left subtree (the grey region in the figure below).</p>

  <div class="row">
<div class="col">
    <figure class="figure">
        <img class="img-fluid" src="../../assets/assignments/mps/mp_mosaics/kdtree-step01.svg" />

    </figure>
</div>
</div>

  <p>The child node is defined by <script type="math/tex">(5,4)</script>, and the splitting plane is based on the
second coordinate. Again, the target node <script type="math/tex">(6,3)</script> is in the left subtree, so
we split left.</p>

  <div class="row">
<div class="col">
    <figure class="figure">
        <img class="img-fluid" src="../../assets/assignments/mps/mp_mosaics/kdtree-step02.svg" />

    </figure>
</div>
</div>

  <p>At the next step, we hit a leaf node, <script type="math/tex">(2,3)</script>. At this point, <script type="math/tex">(2,3)</script>
becomes our current best node, and the distance from the target node to
<script type="math/tex">(2,3)</script> defines a “current best” radius, as indicated by the circle below.
That is, any point outside of this radius cannot be the closest point to the
target, since <script type="math/tex">(2,3)</script> will always be closer; however, there may be a point
within the radius that is closer. We now start the back-traversal to check for
other nodes within this radius.</p>

  <div class="row">
<div class="col">
    <figure class="figure">
        <img class="img-fluid" src="../../assets/assignments/mps/mp_mosaics/kdtree-step03.svg" />

    </figure>
</div>
</div>

  <p>Back at the parent node, <script type="math/tex">(5,4)</script>, we see that it is closer to our target
point than the current best of <script type="math/tex">(2,3)</script>. So, <script type="math/tex">(5,4)</script> is stored as the
current best, and we update the radius.</p>

  <div class="row">
<div class="col">
    <figure class="figure">
        <img class="img-fluid" src="../../assets/assignments/mps/mp_mosaics/kdtree-step04.svg" />

    </figure>
</div>
</div>

  <p>The distance from the target point to the splitting plane for the node
<script type="math/tex">(5,4)</script> is within the current radius, so we must search the other subtree,
indicated by the grey region below. This can be visualized as the hypersphere
(in 2-d, a circle) intersecting the region opposite the splitting plane, as
shown by the red region in the figure below. We descend into the subtree and
find a leaf node <script type="math/tex">(4,7)</script>, which is farther away than our current best.</p>

  <div class="row">
<div class="col">
    <figure class="figure">
        <img class="img-fluid" src="../../assets/assignments/mps/mp_mosaics/kdtree-step05.svg" />

    </figure>
</div>
</div>

  <p>We return all the way to the root node, defined by <script type="math/tex">(7,2)</script>. The distance
between this node and the target is exactly equal to the current radius. In
this case, we check <code class="highlighter-rouge">Point&lt;2&gt;::operator&lt;</code>, which says our current best of <script type="math/tex">(5,
4)</script> is less than <script type="math/tex">(7, 2)</script>, so we don’t replace the current best node.</p>

  <div class="row">
<div class="col">
    <figure class="figure">
        <img class="img-fluid" src="../../assets/assignments/mps/mp_mosaics/kdtree-step06.svg" />

    </figure>
</div>
</div>

  <p>Once again, the distance between the splitting plane defined by <script type="math/tex">(7,2)</script> and
the target point is within the current radius (i.e., the red region exists), so
we must search the other subtree.</p>

  <div class="row">
<div class="col">
    <figure class="figure">
        <img class="img-fluid" src="../../assets/assignments/mps/mp_mosaics/kdtree-step07.svg" />

    </figure>
</div>
</div>

  <p>The target point is less than the splitting plane defined by the node at
<script type="math/tex">(9,6)</script>, so we first descend into the left subtree.</p>

  <div class="row">
<div class="col">
    <figure class="figure">
        <img class="img-fluid" src="../../assets/assignments/mps/mp_mosaics/kdtree-step08.svg" />

    </figure>
</div>
</div>

  <p>We encounter a leaf node, <script type="math/tex">(8,1)</script>, but the distance is greater than the
current best, so we don’t do anything.</p>

  <div class="row">
<div class="col">
    <figure class="figure">
        <img class="img-fluid" src="../../assets/assignments/mps/mp_mosaics/kdtree-step09.svg" />

    </figure>
</div>
</div>

  <p>We finally step back up the tree, and find there are no more regions that
intersect the hypersphere (i.e., no other rectangles intersect the circle).
Therefore, <script type="math/tex">(5,4)</script> is the nearest neighbor, and our search is complete.</p>

  <div class="row">
<div class="col">
    <figure class="figure">
        <img class="img-fluid" src="../../assets/assignments/mps/mp_mosaics/kdtree-step10.svg" />
    </figure>
</div>
</div>

</div>

<h3 id="function-printtree">Function <code class="highlighter-rouge">printTree</code></h3>

<p>We’ve provided this function for you! It allows easy printing of the tree, with
code like this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">KDTree</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">tree</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="n">tree</span><span class="p">.</span><span class="n">printTree</span><span class="p">(</span><span class="n">cout</span><span class="p">);</span>
</code></pre></div></div>

<p>Note that the tree is printed as such:</p>

<pre style="color:#A6E22E;">
                              (<b>51</b>,                                 
                        ______ 35)_____                            
                 ______/               \______                     
              (44,                            {84,                 
            __ <b>43</b>)_                         __ <b>44</b>}_                
         __/       \__                   __/       \__             
      {<b>28</b>,            (<b>43</b>,            {<b>60</b>,            {<b>88</b>,         
       10}             65)             30}             72}         
     /   \           /   \           /   \           /   \         
  {14,    {48,    (42,    (44,    {59,    {74,    {54,    {95,     
   <b>15</b>}     <b>0</b>}      <b>63</b>)     <b>79</b>)     <b>0</b>}      <b>0</b>}      <b>62</b>}     <b>50</b>}     
            \               \               \       \       \      
            {<b>34</b>,            (<b>49</b>,            {<b>82</b>,    {<b>75</b>,    {<b>96</b>,   
             15}             83)             20}     68}     56}   
</pre>

<p>The bold dimensions are the pivot dimensions at each node. The green indicate
that the tree matched the solution tree. The <code class="highlighter-rouge">{ }</code> curly braces indicate that a
node is a land mine - a point that should not be traversed in the given nearest
neighbor search, and will “explode” if you look at it. As these functions are
implemented in <code class="highlighter-rouge">kdtree_extras.hpp</code>, which will not be used for grading, please
do not modify them. All of your <script type="math/tex">k</script>-d tree code should be in <code class="highlighter-rouge">kdtree.h</code> and
 <code class="highlighter-rouge">kdtree.hpp</code>.</p>

<h3 id="implementation-notes">Implementation Notes</h3>

<ul>
  <li>
    <p>This is a template class with one integer template parameter (i.e. <code class="highlighter-rouge">int
Dim</code>). You might be curious why we don’t just let the client specify the
dimension of the tree via the constructor. Since we specify the dimension
through a template, the compiler will assure that the dimension of the
<code class="highlighter-rouge">Point</code> class matches the dimension of our <script type="math/tex">k</script>-d tree.</p>
  </li>
  <li>
    <p>You should follow the rules of <code class="highlighter-rouge">const</code> correctness and design the class to
encapsulate the implementation. That is, any helper functions or instance
variables should be made private.</p>
  </li>
</ul>

<h3 id="testing">Testing</h3>

<p>We have provided a small number of tests for the <code class="highlighter-rouge">KDTree</code> class. The test cases
are defined in <code class="highlighter-rouge">tests/tests_part1.cpp</code>. Be aware that these are deliberately
insufficient. You should add additional test cases to more thoroughly test your
code. You can compile the unit tests with the following command:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make test
</code></pre></div></div>

<p>This will create an executable named <code class="highlighter-rouge">test</code>  which
you can execute with the following command to run tests for Part 1:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./test [part=1]
</code></pre></div></div>

<div class="alert alert-warning" role="alert">
  <p><i class="fa fa-exclamation-circle"></i> 
<strong>Warning</strong>
<code class="highlighter-rouge">KDTree</code> is a templated class. Recall that template functions are not compiled
if they are never called. Make sure all of your code compiles or we will not be
able to grade your work.</p>
</div>

<h3 id="extra-credit-submission">Extra Credit Submission</h3>

<p>For extra credit, you can submit the code you have implemented and tested for
part one of mp_mosaics. You must submit your work before the extra credit deadline as
listed at the top of this page. See <a href="#handing-in-your-code">Handing in Your
Code</a> for instructions.</p>

<h2 id="part2">Part 2</h2>

<p>For the second part of mp_mosaics, you will implement the <code class="highlighter-rouge">mapTiles()</code> function which
maps <code class="highlighter-rouge">TileImages</code> to a <code class="highlighter-rouge">MosaicCanvas</code> based on which <code class="highlighter-rouge">TileImage</code> has an average
color that is closest to the average color of that region in the original
image.</p>

<div class="alert alert-success" role="alert">
  <p><i class="fa fa-location-arrow"></i> 
<strong><code class="highlighter-rouge">LUVAPixel</code> to <code class="highlighter-rouge">Point&lt;3&gt;</code> conversion.</strong></p>

  <p>Your points should be in L-U-V order. That is, L should be the <script type="math/tex">x</script> (0th
dimension), U should be the <script type="math/tex">y</script> (1st dimension), and V should be the
<script type="math/tex">z</script> (2nd dimension).</p>
</div>

<h4 id="classes-involved-in-part-2">Classes Involved in Part 2</h4>

<p>In implementing <code class="highlighter-rouge">mapTiles</code>, you will need to interact with a number of classes,
including the <code class="highlighter-rouge">KDTree</code> class which you’ve built.</p>

<ul>
  <li><a href="../../doxygen/mp_mosaics/classMosaicCanvas.html"><code class="highlighter-rouge">MosaicCanvas</code>: Doxygen</a></li>
  <li><a href="../../doxygen/mp_mosaics/classTileImage.html"><code class="highlighter-rouge">TileImage</code>: Doxygen</a></li>
  <li><a href="../../doxygen/mp_mosaics/classSourceImage.html"><code class="highlighter-rouge">SourceImage</code>: Doxygen</a></li>
</ul>

<p>The source code for all these classes is provided for you, meaning you can look
at their implementation if you have questions about return types, parameters,
or the way the functions work.</p>

<h3 id="the-maptiles-function">The <code class="highlighter-rouge">mapTiles()</code> function</h3>

<p>Please see the <a href="../../doxygen/mp_mosaics/maptiles_8h.html#a4bdec30be914cb272dffdfb9e5aefeba">Doxygen for <code class="highlighter-rouge">mapTiles</code></a>.</p>

<p><code class="highlighter-rouge">mapTiles()</code> is a function that takes a <code class="highlighter-rouge">SourceImage</code> and a vector of
<code class="highlighter-rouge">TileImage</code>s and returns a <code class="highlighter-rouge">MosaicCanvas</code> pointer. It maps the rectangular
regions of the <code class="highlighter-rouge">SourceImage</code> to <code class="highlighter-rouge">TileImage</code>s.</p>

<ul>
  <li>
    <p>Its parameters are a <code class="highlighter-rouge">SourceImage</code> and a constant reference to a
<code class="highlighter-rouge">std::vector</code> of <code class="highlighter-rouge">TileImage</code> objects in that order.</p>
  </li>
  <li>
    <p>It creates a new dynamically allocated <code class="highlighter-rouge">MosaicCanvas</code>, with the same number
of rows and columns as the <code class="highlighter-rouge">SourceImage</code>, and returns a pointer to this
object.</p>
  </li>
  <li>
    <p>For every region in the <code class="highlighter-rouge">SourceImage</code>, <code class="highlighter-rouge">mapTiles()</code> should take the
<code class="highlighter-rouge">TileImage</code> with average color closest to the average color of that region
and place that <code class="highlighter-rouge">TileImage</code> into the <code class="highlighter-rouge">MosaicCanvas</code> in the same tile position
as the <code class="highlighter-rouge">SourceImage</code>’s region.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">map_tiles</code> - The locations of the tiles in the mosaic are defined by a
<code class="highlighter-rouge">MosaicCanvas</code>. This function should create a new <code class="highlighter-rouge">MosaicCanvas</code> which is
appropriately sized based on the rows and columns of tiles in the
<code class="highlighter-rouge">SourceImage</code>. Then, each tile in the <code class="highlighter-rouge">MosaicCanvas</code> should be set to an
appropriate <code class="highlighter-rouge">TileImage</code>, using a <code class="highlighter-rouge">KDTree</code> to find the Nearest Neighbor for
each region. Note that most of the real work here is done by building a
<script type="math/tex">k</script>-d tree and using its nearest neighbor search function. Return a pointer
to the created <code class="highlighter-rouge">MosaicCanvas</code>. You can assume that the caller of the function
will free it after it has been used.</p>
  </li>
</ul>

<p>You may return <code class="highlighter-rouge">NULL</code> in the case of any errors, but we will not test your
function on bad input (e.g., a <code class="highlighter-rouge">SourceImage</code> with 0 rows/columns, an empty
vector of <code class="highlighter-rouge">TileImages</code>, etc.).</p>

<h3 id="implementation-notes-1">Implementation Notes</h3>

<ul>
  <li>There are two classes representing a color in this portion of the MP:
<code class="highlighter-rouge">LUVAPixel</code> and <code class="highlighter-rouge">Point&lt;3&gt;</code>. You will need to convert between these different
representations.
    <ul>
      <li>Note that your points should be in L-U-V order. That is, L should be the <script type="math/tex">x</script> (0th
dimension), U should be the <script type="math/tex">y</script> (1st dimension), and V should be the
<script type="math/tex">z</script> (2nd dimension).</li>
    </ul>
  </li>
  <li>Use your <code class="highlighter-rouge">KDTree</code> class to find the nearest neighbor, which is the tile image
that minimizes average color distances.</li>
  <li>You can easily convert from a <code class="highlighter-rouge">TileImage</code> to its average color using
<code class="highlighter-rouge">TileImage::getAverageColor()</code>. You will also need to convert from an average
color to the <code class="highlighter-rouge">TileImage</code> that would generate that color. You may want to use
the <code class="highlighter-rouge">std::map</code> class to do this.</li>
</ul>

<h3 id="compiling-and-running-a-photomosaic">Compiling and Running A PhotoMosaic</h3>

<p>After finishing both the <code class="highlighter-rouge">KDTree</code> class and the <code class="highlighter-rouge">mapTiles</code> function, you can
compile the executable by linking your code with the provided code with the
following command:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make
</code></pre></div></div>

<p>The executable created is called <code class="highlighter-rouge">mosaics</code>. You can run it as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./mosaics background_image.png [tile_directory/] [number of tiles] [pixels per tile] [output_image.png]
</code></pre></div></div>

<p>Parameters in <code class="highlighter-rouge">[square brackets]</code> are optional. Below are the defaults:</p>

<table class="table">
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Default</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">background_image.png</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">tile_directory/</code></td>
      <td>[EWS only]</td>
      <td>See below (default only valid on EWS)</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">number of tiles</code></td>
      <td>100</td>
      <td>The number of tiles to be placed along the shorter dimension of the source image</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">pixels per tile</code></td>
      <td>50</td>
      <td>The width/height of a <code class="highlighter-rouge">TileImage</code> in the result mosaic. Don’t make this larger than 75 for the provided set of <code class="highlighter-rouge">TileImages</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">output_image.png</code></td>
      <td>mosaic.png</td>
      <td><code class="highlighter-rouge">.png</code>, <code class="highlighter-rouge">.jpg</code>, <code class="highlighter-rouge">.gif</code>, and <code class="highlighter-rouge">.tiff</code> files also supported</td>
    </tr>
  </tbody>
</table>

<h3 id="additional-resources">Additional Resources</h3>

<p>In addition to the given code, we have provided a directory of small thumbnail images which can be used as the <code class="highlighter-rouge">tile_directory</code> of the <code class="highlighter-rouge">mosaics</code> program.
These images are every Instagram photo shared by <a href="https://www.instagram.com/illinois1867/">@illinois1867</a>, <a href="https://www.instagram.com/illinoiscs/">@illinoiscs</a>,
and <a href="https://www.instagram.com/eceillinois/">@eceillinois</a>.</p>

<p>If you are working on EWS, then you can use <code class="highlighter-rouge">/class/cs225/mp5_uiuc-ig/</code> as the <code class="highlighter-rouge">tile_directory</code> (default value). If you are working on your
own machine, you can download them from here: <a href="../../assets/assignments/mps/mp_mosaics/uiuc-ig.zip"><code class="highlighter-rouge">uiuc-ig.zip</code></a>. If you prefer, you can download them directly to your
<code class="highlighter-rouge">mp_mosaics</code> directory by running</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://courses.engr.illinois.edu/cs225/sp2019/assets/assignments/mps/mp_mosaics/uiuc-ig.zip
</code></pre></div></div>

<p>Once downloaded, you need to extract it. Do so by running</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zip -r uiuc-ig.zip uiuc-ig
</code></pre></div></div>

<p>You may also use your own directory of images to create your own PhotoMosaics.
However, for the supplied tests, you should use our provided images.</p>

<h3 id="testing-1">Testing</h3>

<p>We have provided a simple test case for <code class="highlighter-rouge">mapTiles()</code>, which can be run with:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make test
./test [part=2]
</code></pre></div></div>

<p>Be aware that these are deliberately insufficient. You should add additional
test cases to more thoroughly test your code.</p>

<p>We have also provided you with a sample input <code class="highlighter-rouge">sourceimage</code> and output
<code class="highlighter-rouge">mosaiccanvas</code>, which can be tested as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make

# On EWS:
./mosaics tests/source.png

# On your own machine (after downloading and unzip uiuc-ig)
./mosaics tests/source.png uiuc-ig/

wget https://courses.engr.illinois.edu/cs225/sp2019/assets/assignments/mps/mp_mosaics/mosaic-provided-solution.png
diff mosaic.png mosaic-provided-solution.png
</code></pre></div></div>

<h2 id="part-3-creative-your-mosaic">Part 3 (Creative): Your Mosaic!</h2>

<div class="alert alert-warning" role="alert">
  <p><i class="fa fa-exclamation-circle"></i> 
<strong>Solo Portion</strong>
This creative part of the MP must be completed individually and must be significantly different from your partner’s creative work.</p>
</div>

<p>You have two weeks making an mosaic – you should show off your work! You’ll have to gather some pictures, convert them to PNGs, and generate a mosaic using your <code class="highlighter-rouge">mosaics</code> executable.</p>

<p>After generating your mosaic, make sure to commit it to git as <code class="highlighter-rouge">mymosaic.png</code>.</p>

<h4 id="making-a-great-mosaic-gathering-pictures">Making a great mosaic: Gathering Pictures</h4>

<p>A good mosaic requires a lot of tile images.  A baseline for a decent mosaic is ~100 tile images if the images are all different (eg: not all daylight pictures or selfies) and ~1000 for a great mosaic.  You probably already have many images:</p>

<ul>
  <li>If you have an Android, Google Photos usually <a href="https://photos.google.com/">backs up your photos to the cloud at photos.google.com</a>.  You can download them as a ZIP file.</li>
  <li>If you have an iPhone, Apple usually <a href="https://www.icloud.com/">backs up your photos in iCloud</a>.  You can download them as a ZIP file.</li>
  <li>Using a computer and a bit of time, you can download a bunch of your photos frome Facebook, Instagram, Twitter, etc.</li>
</ul>

<h4 id="making-a-great-mosaic-converting-to-png">Making a great mosaic: Converting to PNG</h4>

<p>The program you built requires PNG files as input.  Often photos are JPEG files and must be converted.</p>

<p>Once you have converted all of the image into PNG, place all of the images into a single directory inside of your mp_mosaics folder.  <em>This folder will likely be very large – <strong>you should NOT commit it to git!</strong></em></p>

<h4 id="making-a-great-mosaic-sharing-and-explaining-what-youve-made">Making a great mosaic: Sharing and explaining what you’ve made</h4>

<p>A mosaic looks like a fun Instagram “block” transformation at first glance, but becomes even more amazing when someone understands what they’re seeing – an image made entirely from other images.</p>

<p>If you share you image, it’s best if you describe what you’ve done!  If you want to share it with your peers, post it with <code class="highlighter-rouge">#cs225</code> so we can find it. :)</p>

<div class="mb-3" style="border-radius: 20px; border: solid 1px hsla(273, 100%, 13%, 1); background-color: hsla(273, 100%, 29%, 1); color: hsla(273, 100%, 90%, 1); padding: 10px 10px 0px 10px;">
  <i class="fas fa-share fa-lg" style="font-size: 30px; float: left; margin-left: 10px; margin-right: 10px; margin-bottom: 5px;"></i>
  <b class="text-light">You just made something awesome that never existed before -- you should share your art (but do not have to)!</b>
  <p class="text-light">
    <i>If you share your art on Facebook, Twitter, or Instagram with <b class="text-light">#cs225</b>, I will <i class="far fa-thumbs-up"></i> or <i class="fas fa-heart"></i> the post as soon as I see it.  I think many of your peers will too!</i> &nbsp; &mdash; Wade
  </p>
</div>

<h2 id="grading-information">Grading Information</h2>

<p>The following files are used to grade mp_mosaics:</p>

<ul>
  <li><code class="highlighter-rouge">maptiles.cpp</code> (Part 2 only)</li>
  <li><code class="highlighter-rouge">maptiles.h</code> (Part 2 only)</li>
  <li><code class="highlighter-rouge">kdtree.hpp</code></li>
  <li><code class="highlighter-rouge">kdtree.h</code></li>
  <li><code class="highlighter-rouge">PARTNERS.txt</code></li>
  <li><code class="highlighter-rouge">mymosaic.png</code></li>
</ul>

<p>All other files will not be used for grading.</p>

<div class="d-flex mb-3">
    <a class="btn btn-primary mr-auto ml-auto" style="white-space: normal;" href="../../guides/course-git/index.html">
        <i class="fa fa-book"></i> Guide: How to submit CS 225 work using git
    </a>
</div>

<h2 data-toc-skip="">Good Luck!</h2>

        </main>
    </div>
</div>

<script>
    // Table of contents stuff
    $(function() {
        var navSelector = $('#toc');
        var scopeSelector = $('.container-fluid main');
        console.log(scopeSelector);
        Toc.init({
            $nav: navSelector,
            $scope: scopeSelector,
        });
        $("body").scrollspy({
            target: navSelector,
        });
    })
</script>

<script type="text/javascript" src="../../static/js/graph-load.js"></script>

</body>

<!-- Mirrored from courses.engr.illinois.edu/cs225/sp2019/mps/mosaics/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 09 May 2019 18:15:57 GMT -->
</html>
