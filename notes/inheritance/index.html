<!DOCTYPE html>
<html lang="en">


<!-- Mirrored from courses.engr.illinois.edu/cs225/sp2019/notes/inheritance/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 09 May 2019 18:19:30 GMT -->
<head>
    <meta charset="UTF-8">
    <title>CS 225 | Inheritance</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="base_url" content="/cs225/sp2019">

    <link rel="apple-touch-icon" sizes="57x57" href="../../static/img/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../static/img/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../static/img/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../static/img/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../static/img/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../static/img/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../../static/img/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../../static/img/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../../static/img/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="../../static/img/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../static/img/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="../../static/img/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../static/img/favicon-16x16.png">
<link rel="manifest" href="../../static/img/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="../../static/img/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">


    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css">

<link rel="stylesheet" href="../../static/css/main.css">
<link rel="stylesheet" href="../../static/css/github-highlighting.css">

<script src="https://code.jquery.com/jquery-3.4.0.min.js" integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script>
<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            TeX: {
                extensions: [ "AMSmath.js", "AMSsymbols.js" ]
            },
            tex2jax: {
                inlineMath: [['\\(','\\)'], ['$$','$$']],
                displayMath: [['\\[','\\]']]
            },
        });
</script>

<style>
    svg.graph {
        overflow: visible;
        margin-left: auto;
        margin-right: auto;
        margin-bottom: 10px;
        display: block;
        max-width: 95%;
    }
</style>

<style>
  /* Main items  */
  .main-item {
    border-top-left-radius: calc(1rem - 1px);
    border-top-right-radius: calc(1rem - 1px);
    border-bottom-left-radius: calc(1rem - 1px);
    border-bottom-right-radius: calc(1rem - 1px);
    background-size: cover;
    padding: 10px
  }

  .main-item-mp {
    background-image: url('../../assets/covers/default_mp.svg')
  }

  .main-item-lab {
    background-image: url('../../assets/covers/default_lab.svg')
  }

  .main-item-note {
    background-image: url('../../assets/covers/notes.svg')
  }

  .main-item-body {
    width: 320px;
    height: 180px;
    padding: 20px;

    display: flex;
    border: none !important;
    flex-direction: column;
    justify-content: center;
    background-color: rgba(255, 255, 255, 0.91) !important;
  }

  .main-item-body:hover {
    background-color: rgba(255, 255, 255, 0) !important;
    background: transparent;
    border: transparent;
  }

  .main-item-body:hover * {
    -webkit-text-fill-color: white !important;
    -webkit-background-clip: none !important;
  }

  .main-item-text {
    -webkit-text-fill-color: transparent;
    -webkit-background-clip: text;
    background-size: cover;
  }

  .main-item-text-mp {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/default_mp.svg')
  }

  .main-item-text-lab {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/default_lab.svg')
  }

  .main-item-text-note {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/notes.svg')
  }
</style>

</head>
<body class="mb-3">
<nav class="navbar navbar-expand-md navbar-dark bg-dark">
    <a class="navbar-brand mr-0 mr-md-2" href="../../index.html">
        <img src="../../static/img/UIUC_logo.png" alt="UIUC Logo" width="24" height="32" class="d-inline-block align-top mr-2">
        CS 225
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbar">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item ">
                <a class="nav-link" href="../../pages/lectures.html">Lectures</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../assignments/index.html">Assignments</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../exams/index.html">Exams</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../index.html">Notes</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../pages/resources.html">Resources</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../pages/course_info.html">Course Info</a>
            </li>
        </ul>
    </div>
</nav>

<article class="container py-4">
    <a href="../index.html">Back to Notes</a>
    <header class="mb-4">
        <h1 class="text-dark">Inheritance</h1>
        <span class="text-secondary">by Nathan Walters</span>
    </header>
    <div class="alert alert-info" role="alert">
  <p><i class="fa fa-info-circle"></i> 
Already know the basics of inheritance? Skip straight to <a href="#inheritance-in-c">inheritance in C++</a>,
<a href="#polymorphism-in-c">polymorphism in C++</a>, <a href="#slicing">slicing</a>, <a href="#the-virtual-keyword">the <code class="highlighter-rouge">virtual</code> keyword</a>, or
<a href="#bonus-content-how-do-virtual-methods-work">an advanced description of how virtual methods work</a>.</p>
</div>

<h2 id="motivation-for-inheritance">Motivation for inheritance</h2>

<p><em>Inheritance</em>, along with <em>encapsulation</em>, <em>abstraction</em>, and <em>polymorphism</em>, is one of the pillars of object-oriented programming. Inheritance lets new classes borrow, or <em>inherit</em>, functionality from existing classes. This lets us avoid duplicating functionality that should be shared across a variety of different but related classes. You can also specify a new implementation while remaining the same interface of an existing class.</p>

<h2 id="terminology">Terminology</h2>

<p>When we use inheritance, we say that some new class should inherit the members of an existing class. We call the existing class the <em>base class</em>, and the new class is the <em>derived class</em>. You’ll sometimes hear the derived class referred to as a <em>subclass</em>, and the base class can be called the <em>parent class</em> or the <em>super class</em>.</p>

<p>Inheritance specifies an <em>is-a</em> relationship. Consider fruits: a Honeycrisp <em>is-a</em> Apple, and an Apple <em>is-a</em> Fruit. Such relationships are transitive: a Honeycrisp <em>is-a</em> Fruit.</p>

<h2 id="inheritance-in-c">Inheritance in C++</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;string&gt;
</span>
<span class="k">class</span> <span class="nc">Fruit</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Apple</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Fruit</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">"Apple"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getVariety</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Honeycrisp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Apple</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getVariety</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">"Honeycrisp"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Here’s what our fruits example from above looks like; let’s walk through it.</p>

<h4 id="the-fruit-class">The <code class="highlighter-rouge">Fruit</code> class</h4>

<p>This class declaration should look a bit different than the ones you’re used to seeing, particularly this line:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getVariety</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>This line means that <code class="highlighter-rouge">getVariety()</code> is a <em>pure virtual function</em>. That is, the <code class="highlighter-rouge">Fruit</code> class doesn’t provide an implementation of the <code class="highlighter-rouge">getVariety()</code> function; a subclass will have to provide an implementation. If a class has even one pure virtual function, we call the class <em>abstract</em>. That means we can’t instantiate an instance of the class itself. Consider the following code:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="c1">// Class definitions would go here...</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Fruit</span> <span class="n">f</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we tried to compile this, the compiler would complain that we were trying to instantiate an abstract class:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main.cpp:6:9: error: variable type 'Fruit' is an abstract class
  Fruit f;
        ^
</code></pre></div></div>

<h4 id="the-apple-class">The <code class="highlighter-rouge">Apple</code> class</h4>

<p>Here we see our first example of inheritance! Look at how the <code class="highlighter-rouge">Apple</code> class is declared:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Apple</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Fruit</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is how we declare a class to be a subclass of another class in C++. <code class="highlighter-rouge">public</code> is an access specifier that specifies access rules for public or protected members of the base class. There are three access specifiers that can be used here:</p>

<ul>
  <li><code class="highlighter-rouge">public</code>: For a subclass derived as a <code class="highlighter-rouge">public</code> base class, any <code class="highlighter-rouge">public</code> members in the base class will be <code class="highlighter-rouge">public</code> in the derived class, and any <code class="highlighter-rouge">protected</code> members in the base class will be <code class="highlighter-rouge">protected</code> in the derived class.</li>
  <li><code class="highlighter-rouge">protected</code>: For a subclass derived as a <code class="highlighter-rouge">protected</code> base class, any <code class="highlighter-rouge">public</code> or <code class="highlighter-rouge">protected</code> members in the base class will be <code class="highlighter-rouge">protected</code> in the derived class.</li>
  <li><code class="highlighter-rouge">private</code>: For a subclass derived as a <code class="highlighter-rouge">private</code> base class, any <code class="highlighter-rouge">public</code> or <code class="highlighter-rouge">protected</code> members in the base class will be <code class="highlighter-rouge">private</code> in the derived class.</li>
</ul>

<p>Note that a subclass can never access any private members of any of its parent classes.</p>

<p>The <code class="highlighter-rouge">Apple</code> class implements the <code class="highlighter-rouge">getName()</code> function from the <code class="highlighter-rouge">Fruit</code> class. But we still can’t instantiate an <code class="highlighter-rouge">Apple</code> object! The <code class="highlighter-rouge">Apple</code> class also has a pure virtual method: <code class="highlighter-rouge">getVariety()</code>. This means that <code class="highlighter-rouge">Apple</code> is also an abstract class.</p>

<h4 id="the-honeycrisp-class">The <code class="highlighter-rouge">Honeycrisp</code> class</h4>

<p>This is the last class in our example. It’s derived from <code class="highlighter-rouge">public Apple</code>, and it implements <code class="highlighter-rouge">getVariety()</code>. This means that <code class="highlighter-rouge">Honeycrisp</code> is <strong>not</strong> an abstract class. So we can finally do something useful!</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Honeycrisp</span> <span class="n">h</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"My name is "</span> <span class="o">&lt;&lt;</span> <span class="n">h</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"I am a "</span> <span class="o">&lt;&lt;</span> <span class="n">h</span><span class="p">.</span><span class="n">getVariety</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</code></pre></div></div>

<p>If we were to run the above code, this is the output we’d see:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>My name is Apple
I am a Honeycrisp
</code></pre></div></div>

<h2 id="polymorphism-in-c">Polymorphism in C++</h2>

<p>We’ve now seen an example of how to declare derived classes in C++. But we haven’t really been able to do anything useful with them yet! To show examples of why inheritance is useful, we need to introduce another concept: <em>polymorphism</em>. Polymorphism is the use of a single interface for objects of different types. In our fruits example, the interface determined by <code class="highlighter-rouge">Fruit</code> applies to both <code class="highlighter-rouge">Apple</code> and <code class="highlighter-rouge">Honeycrisp</code>: both also have a <code class="highlighter-rouge">getName()</code> method. And the <code class="highlighter-rouge">Apple</code> interface applies to <code class="highlighter-rouge">Honeycrisp</code> as well, since it has a <code class="highlighter-rouge">getVariety()</code> method.</p>

<p>Let’s add another class to the mix to illustrate how inheritance is useful to us.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">RedDelicious</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Apple</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getVariety</span><span class="p">()</span> <span class="p">{</span>
      <span class="s">"Red Delicious (an objectively bad cultivar)"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now, let’s define a function that prints the type of an Apple:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printType</span><span class="p">(</span><span class="n">Apple</span> <span class="o">*</span><span class="n">apple</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"This apple is a "</span> <span class="o">&lt;&lt;</span> <span class="n">apple</span><span class="o">-&gt;</span><span class="n">getVariety</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can now use this function to print the type of any <code class="highlighter-rouge">Apple</code> we might have!</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Honeycrisp h;
RedDelicious rd;
printType(&amp;h);
printType(&amp;rd);
</code></pre></div></div>

<p>Running the above code would produce the following output:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This apple is a Honeycrisp
This apple is a Red Delicious (an objectively bad cultivar)
</code></pre></div></div>

<p>Note how we pass the <code class="highlighter-rouge">Apple</code> to <code class="highlighter-rouge">printType</code> by pointer. This is important! Remember that <code class="highlighter-rouge">Apple</code> is an abstract class; if we were to try to pass by value, we’d need to create a new instance of an <code class="highlighter-rouge">Apple</code>, which we can’t do! But it’s perfectly OK to have a pointer type of an abstract class, like <code class="highlighter-rouge">Fruit *</code> or <code class="highlighter-rouge">Apple *</code>.</p>

<p>We could also have written the function to take a reference:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printType</span><span class="p">(</span><span class="n">Apple</span> <span class="o">&amp;</span><span class="n">apple</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"This apple is a "</span> <span class="o">&lt;&lt;</span> <span class="n">apple</span><span class="p">.</span><span class="n">getVariety</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Our function calls would look mostly the same, except that we don’t have to take the address <code class="highlighter-rouge">h</code> or <code class="highlighter-rouge">rd</code> this time:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Honeycrisp h;
RedDelicious rd;
printType(h);
printType(rd);
</code></pre></div></div>

<h2 id="slicing">Slicing</h2>

<p>In the fruits example above, we couldn’t declare a function that took a superclass argument because all of the superclasses were abstract. Let’s consider a different example that can illustrate a pitfall when using inherited classes.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from the base class!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from the derived class!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">printHelloMessage</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">.</span><span class="n">sayHello</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">printHelloMessage</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="n">printHelloMessage</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We might expect the above code to print the following output:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello from the base class!
Hello from the derived class!
</code></pre></div></div>

<p>But here’s what’s actualy printed:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello from the base class!
Hello from the base class!
</code></pre></div></div>

<p>This might be somewhat surprising! Let’s take a look at what’s happening.</p>

<p>The first thing to note is that <code class="highlighter-rouge">printHelloMessage</code> takes an <code class="highlighter-rouge">A</code> object by <em>value</em>. Remember that when an object is passed by value, a copy of the original object is created. So, when we pass an instance of <code class="highlighter-rouge">B</code> to a function that takes an <code class="highlighter-rouge">A</code> by value, we’re actually copying the instance of <code class="highlighter-rouge">B</code> into an instance of <code class="highlighter-rouge">A</code>. But the memory allocated for that instance of <code class="highlighter-rouge">A</code> doesn’t have any space to rememebr that it was originally an instance of <code class="highlighter-rouge">B</code>. Since the <code class="highlighter-rouge">A</code> class has its own definition of <code class="highlighter-rouge">sayHello</code>, this is what’s ultimately used.</p>

<p>We call this <em>slicing</em> because the information that something is an instance of a subclass is lost when we copy it into an instance of its super class.</p>

<p>How can we avoid this problem? You’ve already seen the answer to that in the last section! If we pass an object by pointer or by reference instead, we don’t need to copy the object when the function is called. Instead, the <em>actual</em> type that the pointer points to is looked up at runtime so that the correct member function can be called.</p>

<p>With that knowledge, let’s revise our code a bit:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">printHelloMessage</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">.</span><span class="n">sayHello</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">printHelloMessage</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="n">printHelloMessage</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s look at what this new code would print.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello from the base class!
Hello from the base class!
</code></pre></div></div>

<p>Hmm. Not quite what we want yet! Turns out there’s one more piece that we’re missing.</p>

<h2 id="the-virtual-keyword">The <code class="highlighter-rouge">virtual</code> keyword</h2>

<p>When we have a pointer to a base class, the compiler doesn’t know by default that it needs to potentially look at subclasses for a different implementation of a function from the base class. In the <code class="highlighter-rouge">A</code>/<code class="highlighter-rouge">B</code> example from above, we find ourselves in exactly that situation: <code class="highlighter-rouge">B</code> provides a different implementation of <code class="highlighter-rouge">sayHello()</code> than <code class="highlighter-rouge">A</code> does. To tell the compiler that a subclass might override a function, we can tell it that with the <code class="highlighter-rouge">virtual</code> keyword. Let’s revise our code one more time:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from the base class!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from the derived class!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">printHelloMessage</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">.</span><span class="n">sayHello</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">printHelloMessage</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="n">printHelloMessage</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Our only change this time was adding the <code class="highlighter-rouge">virtual</code> keyword before the definition of the <code class="highlighter-rouge">sayHello()</code> member function in <code class="highlighter-rouge">A</code>. Now, if we run our code, we see that we finally get the output we’ve been looking for:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello from the base class!
Hello from the derived class!
</code></pre></div></div>

<p>Yay!</p>

<p>If you were paying attention, you’ll remember you already saw the <code class="highlighter-rouge">virtual</code> keyword earlier in this note when we were discussing the fruits example. We declared <code class="highlighter-rouge">Food</code> as having a pure-virtual <code class="highlighter-rouge">getName()</code> function:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getName</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>The meaning of the <code class="highlighter-rouge">virtual</code> keyword is the same there: it says to the compiler “Hey, when you’re trying to call this function on a pointer to some <code class="highlighter-rouge">Food</code> object, make sure you look in subclasses for a more specific implementation!” The <code class="highlighter-rouge">= 0</code> just tells the compiler that the <code class="highlighter-rouge">Food</code> class definitely doesn’t provide an implementation of this function itself.</p>

<p>Note that you only have to add the virtual keyword to the “most-base” class - that is, the class in the inheritance hierarchy where a function first appears. In the context of the fruit example, we could provide an implementation for <code class="highlighter-rouge">getName()</code> in the <code class="highlighter-rouge">Honeycrisp</code> class even though the intermediate <code class="highlighter-rouge">Apple</code> class didn’t re-declare a <code class="highlighter-rouge">virtual std::string getName()</code> function.</p>

<p>If you’re curious about how the <code class="highlighter-rouge">virtual</code> keyword works, read on! This is advanced content, so you won’t be tested on this on an exam. Nonetheless, it’s still interesting (or, at least, I think it is).</p>

<h2 id="bonus-content-how-do-virtual-methods-work">Bonus content: how do virtual methods work?</h2>

<div class="alert alert-info" role="alert">
  <p><i class="fa fa-info-circle"></i> 
The following section is advanced content that’s outside the scope of this class.
However, it’s still interesting if you’re curious about how C++ works at a lower level.</p>
</div>

<p>First, a little bit of background on how functions are implemented in C++ (some of this might be a little hand-wavey; don’t crucify me, ECE majors!). This assumes cursory knowledge of how computers work (what instructions are, how they’re executed, and how memory works).</p>

<p>A function is essentially a sequence of instructions that operate on some data. Remember that instructions are just data too; that means they have their own location in memory. That gives us something interesting: we can have a pointer to a function! This is illustrated here:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="kt">void</span> <span class="nf">sayHello</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello, world!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Declare a variable "funcPointer" that can hold a poitner</span>
  <span class="c1">// to a function that takes zero arguments and returns nothing</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">funcPointer</span><span class="p">)();</span>
  <span class="c1">// Assign sayHello to funcPointer</span>
  <span class="n">funcPointer</span> <span class="o">=</span> <span class="n">sayHello</span><span class="p">;</span>
  <span class="c1">// Tell the runtime to interpret "funcPointer" as a void*, which we can then</span>
  <span class="c1">// print to see the address of the function</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">funcPointer</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="c1">// We can even "call" a function pointer!</span>
  <span class="n">funcPointer</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That code will print the following output when run. Note that the address of <code class="highlighter-rouge">funcPointer</code> (<code class="highlighter-rouge">0x400830</code>) might be different depending on the machine you’re working on.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0x400830
Hello, world!
</code></pre></div></div>

<p>When a method is declared as <code class="highlighter-rouge">virtual</code>, the compiler will add a pointer to that function to a so-called <em>virtual method table</em> for the class. These functions are the same for all instances of that class, so the same table will be used for all instances as well.</p>

<p>Next, when you instantiate an object that has virtual methods, a pointer to this virtual method table is added as a hidden member of that object. This pointer is called a <em>virtual table pointer</em>, <em>vpointer</em>, or just <em>VPTR</em>. Now, when you try to call a function on an object with virtual methods, the compiler will use the VPTR to look up which implementation to actuall call at runtime!</p>

<p>Let’s walk through a concrete example using the <code class="highlighter-rouge">A</code>/<code class="highlighter-rouge">B</code> code from above. Here it is again for convenience:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from the base class!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello from the derived class!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">printHelloMessage</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">a</span><span class="p">.</span><span class="n">sayHello</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
  <span class="n">printHelloMessage</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="n">printHelloMessage</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When the compiler creates space for the object <code class="highlighter-rouge">b</code>, it’ll include a pointer to the virtual method table for the <code class="highlighter-rouge">B</code> class, which includes the implementation of <code class="highlighter-rouge">sayHello()</code> that prints “Hello from the derived class!” When we call <code class="highlighter-rouge">printHelloMessage()</code>, the virtual table pointer will be used to figure out the correct version of the function to call.</p>

<p>A lot of people ask why methods aren’t virtual by default in C++ like they are in Java or other languages. One reason is that C++ is very focused on efficiency and speed. If a method isn’t ever going to be overridden by a subclass, the compiler can skip generating the code to look up the correct function to call at runtime. This means that the resulting code will run faster! So, unless you specifically opt in to this behavior with the <code class="highlighter-rouge">virtual</code> keyboard, C++ defaults to doing the fast, efficient thing.</p>

<p>This is just an overview of how it works; <a href="https://en.wikipedia.org/wiki/Virtual_method_table">Wikipedia</a> provides a much more comprehensive look at virtual methods. Check it out if this was interesting for you!</p>

</article>

</body>

<!-- Mirrored from courses.engr.illinois.edu/cs225/sp2019/notes/inheritance/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 09 May 2019 18:19:30 GMT -->
</html>
