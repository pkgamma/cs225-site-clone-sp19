<!DOCTYPE html>
<html lang="en">


<!-- Mirrored from courses.engr.illinois.edu/cs225/sp2019/notes/mst/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 09 May 2019 18:17:28 GMT -->
<head>
    <meta charset="UTF-8">
    <title>CS 225 | Minimum Spanning Tree</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="base_url" content="/cs225/sp2019">

    <link rel="apple-touch-icon" sizes="57x57" href="../../static/img/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../static/img/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../static/img/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../static/img/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../static/img/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../static/img/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../../static/img/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../../static/img/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../../static/img/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="../../static/img/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../static/img/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="../../static/img/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../static/img/favicon-16x16.png">
<link rel="manifest" href="../../static/img/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="../../static/img/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">


    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css">

<link rel="stylesheet" href="../../static/css/main.css">
<link rel="stylesheet" href="../../static/css/github-highlighting.css">

<script src="https://code.jquery.com/jquery-3.4.0.min.js" integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script>
<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            TeX: {
                extensions: [ "AMSmath.js", "AMSsymbols.js" ]
            },
            tex2jax: {
                inlineMath: [['\\(','\\)'], ['$$','$$']],
                displayMath: [['\\[','\\]']]
            },
        });
</script>

<style>
    svg.graph {
        overflow: visible;
        margin-left: auto;
        margin-right: auto;
        margin-bottom: 10px;
        display: block;
        max-width: 95%;
    }
</style>

<style>
  /* Main items  */
  .main-item {
    border-top-left-radius: calc(1rem - 1px);
    border-top-right-radius: calc(1rem - 1px);
    border-bottom-left-radius: calc(1rem - 1px);
    border-bottom-right-radius: calc(1rem - 1px);
    background-size: cover;
    padding: 10px
  }

  .main-item-mp {
    background-image: url('../../assets/covers/default_mp.svg')
  }

  .main-item-lab {
    background-image: url('../../assets/covers/default_lab.svg')
  }

  .main-item-note {
    background-image: url('../../assets/covers/notes.svg')
  }

  .main-item-body {
    width: 320px;
    height: 180px;
    padding: 20px;

    display: flex;
    border: none !important;
    flex-direction: column;
    justify-content: center;
    background-color: rgba(255, 255, 255, 0.91) !important;
  }

  .main-item-body:hover {
    background-color: rgba(255, 255, 255, 0) !important;
    background: transparent;
    border: transparent;
  }

  .main-item-body:hover * {
    -webkit-text-fill-color: white !important;
    -webkit-background-clip: none !important;
  }

  .main-item-text {
    -webkit-text-fill-color: transparent;
    -webkit-background-clip: text;
    background-size: cover;
  }

  .main-item-text-mp {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/default_mp.svg')
  }

  .main-item-text-lab {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/default_lab.svg')
  }

  .main-item-text-note {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/notes.svg')
  }
</style>

</head>
<body class="mb-3">
<nav class="navbar navbar-expand-md navbar-dark bg-dark">
    <a class="navbar-brand mr-0 mr-md-2" href="../../index.html">
        <img src="../../static/img/UIUC_logo.png" alt="UIUC Logo" width="24" height="32" class="d-inline-block align-top mr-2">
        CS 225
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbar">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item ">
                <a class="nav-link" href="../../pages/lectures.html">Lectures</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../assignments/index.html">Assignments</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../exams/index.html">Exams</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../index.html">Notes</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../pages/resources.html">Resources</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../pages/course_info.html">Course Info</a>
            </li>
        </ul>
    </div>
</nav>

<article class="container py-4">
    <a href="../index.html">Back to Notes</a>
    <header class="mb-4">
        <h1 class="text-dark">Minimum Spanning Tree</h1>
        <span class="text-secondary">by Jenny Chen</span>
    </header>
    <h2 id="definition">Definition</h2>
<p>A <strong>spanning tree</strong> of a graph <em>G</em> is a connected acyclic subgraph of <em>G</em> that contains every node of <em>G</em>. A <strong>minimum spanning tree</strong> (MST) of a weighted graph <em>G</em> is a spanning tree of <em>G</em> which has the minimum weight sum on its edges.</p>

<div class="row">
    <div class="col-sm">
        <figure class="figure">
            <img class="img-fluid" src="../../assets/notes/mst/sample_graph.png" />
            <figcaption class="figure-caption text-center">
              Graph <i>G</i>
            </figcaption>
        </figure>
    </div>
    <div class="col-sm">
        <figure class="figure">
            <img class="img-fluid" src="../../assets/notes/mst/sample_spanning_tree.png" />
            <figcaption class="figure-caption text-center">
              The orange highlighted subgraph is a spanning tree of <i>G</i>
            </figcaption>
        </figure>
    </div>
    <div class="col-sm">
        <figure class="figure">
            <img class="img-fluid" src="../../assets/notes/mst/sample_mst.png" />
            <figcaption class="figure-caption text-center">
              The purple highlighted subgraph is the minimum spanning tree of weighted <i>G</i>
            </figcaption>
        </figure>
    </div>
</div>

<h2 id="finding-the-mst-of-a-graph">Finding the MST of a graph</h2>
<p>There are multiple ways to find the MST of a graph. The most naive and brute force way is to try all possible subgraphs of <em>G</em>, find the ones that are spanning trees, then find the one with minimum weight. This would take exponential time. There are algorithms that can do this faster.</p>

<h3 id="kruskals-algorithm">Kruskal’s Algorithm</h3>
<p>The high level idea of Kruskal’s algorithm is to build the spanning tree by inserting edges. There are two restrictions as we insert the edges:</p>

<ol>
  <li>To keep the tree minimum weight, we insert the edges from low weights to high weights.</li>
  <li>To keep the tree acyclic, the edges we add must not introduce a cycle.</li>
</ol>

<p>To satisfy the first condition, we sort the edges and insert them in ascending order of weight. To satisfy the second condition, we have to keep track of nodes which are already in the same connected component (smaller trees). Imagine we are half way in our algorithm. Since we are selecting edges purely by weight, there could be multiple disconnected small trees. For example our graph could look like this.</p>

<div class="row">
   <div class="col-12 col-sm-8 offset-sm-2 col-lg-6 offset-lg-3">
       <figure class="figure">
           <img class="img-fluid" src="../../assets/notes/mst/Forest.png" />
           <figcaption class="figure-caption">
             At this stage <code>a</code>, <code>b</code>, and <code>c</code> form a small tree, so do <code>f</code> and <code>e</code>. Inserting edge <code>bc</code> would introduce a cycle.
           </figcaption>
       </figure>
   </div>
</div>

<p>We can use disjoint sets for keeping track of which nodes are in which components. When we insert an edge, we union the two sets that the two nodes belong to. Conceptually this is adding an edge between the two small trees and merging them into a bigger tree. If the edge we are about to insert connects two nodes that are in the same set, then we cannot insert this edge because it would introduce a cycle.</p>

<div class="row">
   <!-- On example of Kruskal's Algorithm -->
     <div class="col-12 col-sm-8 offset-sm-2 col-lg-6 offset-lg-3">
       <div id="carouselExampleControls1" class="carousel slide" data-ride="carousel">
           <div class="carousel-inner">
             
               
               <div class="carousel-item  active">
                 <img class="d-block w-100" src="../../assets/notes/mst/kruskal_0.png" alt="Kruskal's demo image 0" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/kruskal_1.png" alt="Kruskal's demo image 1" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/kruskal_2.png" alt="Kruskal's demo image 2" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/kruskal_3.png" alt="Kruskal's demo image 3" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/kruskal_4.png" alt="Kruskal's demo image 4" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/kruskal_5.png" alt="Kruskal's demo image 5" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/kruskal_6.png" alt="Kruskal's demo image 6" />
               </div>
             
           </div>
           <a class="carousel-control-prev dark" href="#carouselExampleControls1" role="button" data-slide="prev">
               <span class="carousel-control-prev-icon" aria-hidden="true"></span>
               <span class="sr-only">Previous</span>
           </a>
           <a class="carousel-control-next dark" href="#carouselExampleControls1" role="button" data-slide="next">
               <span class="carousel-control-next-icon" aria-hidden="true"></span>
               <span class="sr-only">Next</span>
           </a>
        </div>
        <figcaption class="figure-caption text-center">
          A step by step example of Kruskal's Algorithm.
        </figcaption>
     </div>
</div>
<p><br /></p>

<p>Here is the pseudocode for Kruskal’s algorithm.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Sort the edges in increasing order of weights
   (You can do this with a heap, or simply sort them in an array)
2. Initialize a separate disjoint set for each vertex
3. for each edge uv in sorted order:
4.   if u and v are in different sets:
5.     add uv to solution
6.     union the sets that u and v belong to
</code></pre></div></div>
<p>The runtime for this algorithm using either heap or sorted array are both <script type="math/tex">O(m\cdot log(m))</script>, which is dominated by the sorting of edges.</p>

<h3 id="prims-algorithm">Prim’s Algorithm</h3>
<p>Another algorithm that finds MST efficiently is Prim’s Algorithm. The idea of Prim’s algorithm is to expand the tree by adding the smallest weight edge from “outgoing edges”. The “outgoing edges” are the edges that connect a node in our tree on one end, and a node that’s not in our tree on the other end.</p>

<div class="row">
   <div class="col-12 col-sm-8 offset-sm-2 col-lg-6 offset-lg-3">
       <figure class="figure">
           <img class="img-fluid" src="../../assets/notes/mst/outgoing_edges.png" />
           <figcaption class="figure-caption">
             In this example, our current tree is colored with dark blue. The light blue edges are the "outgoing edges".
           </figcaption>
       </figure>
   </div>
</div>

<p>At the start of Prim’s algorithm, we choose an arbitrary node in the graph as a “starting tree”. Then for all the “outgoing edges” of our tree, we choose the one with the smallest weight and add it to our tree. This step expands our tree by one node. We keep adding edges like this until our tree contains all nodes in the graph.</p>

<div class="row">
   <!-- On example of Kruskal's Algorithm -->
     <div class="col-12 col-sm-8 offset-sm-2 col-lg-6 offset-lg-3">
       <div id="carouselExampleControls2" class="carousel slide" data-ride="carousel">
           <div class="carousel-inner">
             
               
               <div class="carousel-item  active">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_1.png" alt="Kruskal's demo image 1" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_2.png" alt="Kruskal's demo image 2" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_3.png" alt="Kruskal's demo image 3" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_4.png" alt="Kruskal's demo image 4" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_5.png" alt="Kruskal's demo image 5" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_6.png" alt="Kruskal's demo image 6" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_7.png" alt="Kruskal's demo image 7" />
               </div>
             
           </div>
           <a class="carousel-control-prev dark" href="#carouselExampleControls2" role="button" data-slide="prev">
               <span class="carousel-control-prev-icon" aria-hidden="true"></span>
               <span class="sr-only">Previous</span>
           </a>
           <a class="carousel-control-next dark" href="#carouselExampleControls2" role="button" data-slide="next">
               <span class="carousel-control-next-icon" aria-hidden="true"></span>
               <span class="sr-only">Next</span>
           </a>
        </div>
        <figcaption class="figure-caption">
          One step by step example of Prim's algorithm high level idea. The dark blue edges and nodes are the current tree. The light blue edges are "outgoing edges" of our tree. The light purple edges are edges within the tree.
        </figcaption>
     </div>
</div>
<p><br /></p>

<p>But how do we select the minimum “outgoing edge” in code? We can think from a different perspective. Instead of selecting from edges, we can choose from the immediate neighbor nodes of the tree. We can assign each node the minimum weight it takes to add it to our tree, and then choose the node with minimum such value. For those nodes that are not our immediate neighbors, assign them infinity so that they wouldn’t be considered. We can use the data structure heap to select the node with minimum weight efficiently.</p>

<div class="row">
   <div class="col-12 col-sm-8 offset-sm-2 col-lg-6 offset-lg-3">
       <figure class="figure">
           <img class="img-fluid" src="../../assets/notes/mst/prim_low_example.png" />
           <figcaption class="figure-caption">
             In this example, our current tree is colored with dark purple. The immediate neighbors are colored with light orange. Notice that node <code>g</code> has weight 6 instead of 9 because 6 is a smaller weight edge between <code>g</code> and our tree.
           </figcaption>
       </figure>
   </div>
</div>

<p>The next question is how do we update the weights on each node as the algorithm proceeds? Notice that when we add a new node into our tree, the only nodes that change weights are the neighbors of the new node we added. Therefore each time we add a node, we update the weights of the neighbors of this node.</p>

<div class="row">
   <!-- On example of Kruskal's Algorithm -->
     <div class="col-12 col-sm-8 offset-sm-2 col-lg-6 offset-lg-3">
       <div id="carouselExampleControls3" class="carousel slide" data-ride="carousel">
           <div class="carousel-inner">
             
               
               <div class="carousel-item  active">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_low_1.png" alt="Kruskal's demo image 1" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_low_2.png" alt="Kruskal's demo image 2" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_low_3.png" alt="Kruskal's demo image 3" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_low_4.png" alt="Kruskal's demo image 4" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_low_5.png" alt="Kruskal's demo image 5" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_low_6.png" alt="Kruskal's demo image 6" />
               </div>
             
               
               <div class="carousel-item ">
                 <img class="d-block w-100" src="../../assets/notes/mst/prim_low_7.png" alt="Kruskal's demo image 7" />
               </div>
             
           </div>
           <a class="carousel-control-prev dark" href="#carouselExampleControls3" role="button" data-slide="prev">
               <span class="carousel-control-prev-icon" aria-hidden="true"></span>
               <span class="sr-only">Previous</span>
           </a>
           <a class="carousel-control-next dark" href="#carouselExampleControls3" role="button" data-slide="next">
               <span class="carousel-control-next-icon" aria-hidden="true"></span>
               <span class="sr-only">Next</span>
           </a>
        </div>
        <figcaption class="figure-caption">
          One step by step example of Prim's algorithm implementation which starts with node <code>c</code>.
        </figcaption>
     </div>
</div>
<p><br /></p>

<p>Here is the pseudocode of Prim’s algorithm.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. Create a heap and insert all vertices into the it with the weight infinity.
2. Choose an arbitrary node and set its weight to 0.
3. while the heap is not empty:
4.   remove the node with minimum weight from the heap, call it v
5.   add the edge that connects v and its predecessor to the solution
6.   for each neighbor u of v:
7.     if the weight of edge uv is less than the weight of u:
8.       update the weight of u to be weight of uv
9.       update u's predecessor to v
</code></pre></div></div>

<p>The runtime for this algorithm using a binary heap (the kind that is taught in this class) is <script type="math/tex">O(m\cdot log(m))</script>. However it could be faster if we use a <a href="https://brilliant.org/wiki/fibonacci-heap/">fibonacci heap</a>, which can decrease its element’s priority in <script type="math/tex">O(1)</script> time. If a fibonacci heap is used, this algorithm has runtime of <script type="math/tex">O(n\cdot log(n) + m)</script>.</p>

<h4 id="why-do-these-algorithms-work">Why do these algorithms work?</h4>
<p>Even though both Kruskal’s and Prim’s algorithm make intuitive sense, both of them are making optimal <strong>local</strong> choices at each step. This means they are not looking at the overall graph as a whole at any time. If you are curious about “why do they work?”, take CS 374 to find out.</p>

</article>

</body>

<!-- Mirrored from courses.engr.illinois.edu/cs225/sp2019/notes/mst/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 09 May 2019 18:17:55 GMT -->
</html>
