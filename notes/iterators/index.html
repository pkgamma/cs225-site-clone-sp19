<!DOCTYPE html>
<html lang="en">


<!-- Mirrored from courses.engr.illinois.edu/cs225/sp2019/notes/iterators/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 09 May 2019 18:19:20 GMT -->
<head>
    <meta charset="UTF-8">
    <title>CS 225 | Iterators</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="base_url" content="/cs225/sp2019">

    <link rel="apple-touch-icon" sizes="57x57" href="../../static/img/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../static/img/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../static/img/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../static/img/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../static/img/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../static/img/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../../static/img/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../../static/img/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../../static/img/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="../../static/img/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../static/img/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="../../static/img/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../static/img/favicon-16x16.png">
<link rel="manifest" href="../../static/img/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="../../static/img/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">


    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css">

<link rel="stylesheet" href="../../static/css/main.css">
<link rel="stylesheet" href="../../static/css/github-highlighting.css">

<script src="https://code.jquery.com/jquery-3.4.0.min.js" integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script>
<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            TeX: {
                extensions: [ "AMSmath.js", "AMSsymbols.js" ]
            },
            tex2jax: {
                inlineMath: [['\\(','\\)'], ['$$','$$']],
                displayMath: [['\\[','\\]']]
            },
        });
</script>

<style>
    svg.graph {
        overflow: visible;
        margin-left: auto;
        margin-right: auto;
        margin-bottom: 10px;
        display: block;
        max-width: 95%;
    }
</style>

<style>
  /* Main items  */
  .main-item {
    border-top-left-radius: calc(1rem - 1px);
    border-top-right-radius: calc(1rem - 1px);
    border-bottom-left-radius: calc(1rem - 1px);
    border-bottom-right-radius: calc(1rem - 1px);
    background-size: cover;
    padding: 10px
  }

  .main-item-mp {
    background-image: url('../../assets/covers/default_mp.svg')
  }

  .main-item-lab {
    background-image: url('../../assets/covers/default_lab.svg')
  }

  .main-item-note {
    background-image: url('../../assets/covers/notes.svg')
  }

  .main-item-body {
    width: 320px;
    height: 180px;
    padding: 20px;

    display: flex;
    border: none !important;
    flex-direction: column;
    justify-content: center;
    background-color: rgba(255, 255, 255, 0.91) !important;
  }

  .main-item-body:hover {
    background-color: rgba(255, 255, 255, 0) !important;
    background: transparent;
    border: transparent;
  }

  .main-item-body:hover * {
    -webkit-text-fill-color: white !important;
    -webkit-background-clip: none !important;
  }

  .main-item-text {
    -webkit-text-fill-color: transparent;
    -webkit-background-clip: text;
    background-size: cover;
  }

  .main-item-text-mp {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/default_mp.svg')
  }

  .main-item-text-lab {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/default_lab.svg')
  }

  .main-item-text-note {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/notes.svg')
  }
</style>

</head>
<body class="mb-3">
<nav class="navbar navbar-expand-md navbar-dark bg-dark">
    <a class="navbar-brand mr-0 mr-md-2" href="../../index.html">
        <img src="../../static/img/UIUC_logo.png" alt="UIUC Logo" width="24" height="32" class="d-inline-block align-top mr-2">
        CS 225
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbar">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item ">
                <a class="nav-link" href="../../pages/lectures.html">Lectures</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../assignments/index.html">Assignments</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../exams/index.html">Exams</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../index.html">Notes</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../pages/resources.html">Resources</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../pages/course_info.html">Course Info</a>
            </li>
        </ul>
    </div>
</nav>

<article class="container py-4">
    <a href="../index.html">Back to Notes</a>
    <header class="mb-4">
        <h1 class="text-dark">Iterators</h1>
        <span class="text-secondary">by Nathan Walters</span>
    </header>
    <div class="alert alert-info" role="alert">
  <p><i class="fa fa-info-circle"></i> 
Already know the basics of iterators? Skip straight to <a href="#iterators-in-c">a code example</a>,
<a href="#range-based-for-loops">range-based for loops</a>, or
<a href="#moving-beyond-linear-structures">using iterators with non-linear data structures</a>.</p>
</div>

<h2 id="motivation-for-iterators">Motivation for iterators</h2>

<p>In C++ (and in general) we often work with collections of elements—in fact, such data structures
are the focus of this class! We often want to do something with all the elements in a
particular data structure, such as “add five to every integer in a list” or
“print every node in a tree”. The kind of code we write to do these iterations often varies
a lot depending on the type of data structure we’re using. We might need a single for loop for
an array, two nested for loops for the pixels in an image, or some recursive function calls for a tree.</p>

<p>An <em>iterator</em> provides an abstraction over this process of iterating over some elements of a
data structure, or <em>container</em>. As long as you can define an order in which to iterate over the
elements in a container, you can write an iterator for it! What makes C++ iterators so powerful is that
they all have the same interface. You could use the exact same code to iterate over a list, 2D array, tree, or graph.</p>

<h2 id="a-conceptual-model">A conceptual model</h2>

<p><img src="../../assets/notes/iterators/iterators1.png" class="img-fluid d-block mx-auto" style="max-width: 250px;" /></p>

<p>Here we have an array of integers with some iterators represented by purple boxes. There are two iterators:
one points to the first element in our container, and one points to the “one-past-the-end” position of the
container’s data. At this point, we could ask the iterator “What’s your current element?”
and it would respond “5”.</p>

<p>Now, let’s advance the iterator to the next element. As long as the iterator isn’t at the “one-past-the-end”
position, we can keep advancing it.</p>

<p><img src="../../assets/notes/iterators/iterators2.png" class="img-fluid d-block mx-auto" style="max-width: 250px;" /></p>

<p>The iterator would now tell us its current element is “2”. Let’s advance it a few more positions to the end
of the array.</p>

<p><img src="../../assets/notes/iterators/iterators3.png" class="img-fluid d-block mx-auto" style="max-width: 250px;" /></p>

<p>We can still ask the iterator what element it’s at, and it would say “9”. Now let’s advance it one more time.</p>

<p><img src="../../assets/notes/iterators/iterators4.png" class="img-fluid d-block mx-auto" style="max-width: 250px;" /></p>

<p>The iterator that started at the beginning of the array is now at the “one-past-the-end” position. At this point,
we can’t advance the iterator any further, and we also can’t check what element the iterator is at; this isn’t
defined.</p>

<p>This probably looks like your conceptual model of how array iteration already works, and it’s indeed largely the same.
But remember what makes iterators so powerful: they can work on any data structure, not just arrays!</p>

<h2 id="iterators-in-c">Iterators in C++</h2>

<p>Now that you have a high-level of what an iterator is and does, let’s consider the following code.
It creates a <a href="https://en.cppreference.com/w/cpp/container/vector"><code class="highlighter-rouge">std::vector</code></a> of 5 integers and prints them out.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is using the style of for loop that you’re probably familiar with: initialize an index
variable to zero and increment it once per iteration until you hit the end of the list.</p>

<p>Let’s see what that code would look like if we used iterators instead:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This might look confusing at first; let’s break it down.</p>

<p>First, notice that we declare a variable <code class="highlighter-rouge">it</code> of type <code class="highlighter-rouge">std::vector&lt;int&gt;::iterator</code>.
As you should be able to infer from its type, <code class="highlighter-rouge">it</code> is the iterator itself! We initialize it
to <code class="highlighter-rouge">numbers.begin()</code>. A container that supports iteration has a member function
called <code class="highlighter-rouge">begin()</code> that returns an iterator pointing to the first element in the container.</p>

<p>Next, we compare <code class="highlighter-rouge">it</code> with <code class="highlighter-rouge">numbers.end()</code>. The <code class="highlighter-rouge">end()</code> function returns an iterator that
refers to the “one-past-the-end” position of the container. Why does it do this?
Think of a “classic” for loop over some array <code class="highlighter-rouge">arr</code>:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Do some stuff here</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If <code class="highlighter-rouge">arr</code> has 10 elements, we can only access <code class="highlighter-rouge">arr[0]</code> through <code class="highlighter-rouge">a[9]</code>, but we’ll check <code class="highlighter-rouge">i &lt; 10</code>
in the for loop. 10 is analagous to the “one-past-the-end” iterator.</p>

<p>In the last statement of the for loop, we call <code class="highlighter-rouge">++it</code>. It might look a bit weird to be calling <code class="highlighter-rouge">++</code>
on a non-primitive type; we usually only call it on something like an integer. But remember that C++,
in all its glorious flexibility, allows us to override operators for certain types. In this case,
iterators override the pre-increment operator. Calling this operator moves the iterator to the “next”
element in the container.</p>

<p>Now, in the body of the for loop, we use <code class="highlighter-rouge">*it</code> to access the element in the container that <code class="highlighter-rouge">it</code>
currently “points” at. Again, this might look weird—you usually only use the <code class="highlighter-rouge">*</code> operator to
dereference pointers. As with <code class="highlighter-rouge">++</code>, iterators overload this operator to mean “give me whatever
element you’re at right now”. In this way, an iterator behaves a little like a pointer, but remember
it isn’t actually a pointer itself!</p>

<h2 id="range-based-for-loops">Range-based for loops</h2>

<p>Compared to the style of for loop you’re used to, iterators might appear to be a lot of extra code.
Let’s compare our loop again, both without and with iterators.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{}</span>
</code></pre></div></div>

<p>The second one certainly looks much longer and more unweildy than the first. Thankfully, the
designers of C++ thought of this and gave us <em>range-based for loops</em>. Let’s use one to rewrite
our previous example.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">num</span> <span class="o">:</span> <span class="n">numbers</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Much nicer, right? In fact, many people might even prefer this to a “classic” for loop with an integer index.
You can read the 6th line as “for each integer <code class="highlighter-rouge">num</code> in <code class="highlighter-rouge">numbers</code>”. For this reason, this style
of loop is sometimes called a “for-each” loop.</p>

<p>This is what we call <em>syntactic sugar</em> on top of iterators. It takes advantage of
the fact that iterators and the containers that provide them have standardized interfaces.
The compiler sees that <code class="highlighter-rouge">numbers</code> has <code class="highlighter-rouge">begin()</code> and <code class="highlighter-rouge">end()</code> methods that return iterators,
so it can automatically generate the calls to those functions, check if the iterator is
equal to <code class="highlighter-rouge">end()</code>, and call <code class="highlighter-rouge">++</code> after each iteration. In fact, the code that the compiler
will generate for this loop is almost exactly the same as the more explicit iterator code
we saw above. The compiler even automatically “dereferences” the iterator for us: note that
we can use <code class="highlighter-rouge">num</code> directly in the body of the loop.</p>

<h2 id="moving-beyond-linear-structures">Moving beyond linear structures</h2>

<p>So far, we’ve only looked at iterators in the context of a <code class="highlighter-rouge">std::vector</code>, which is a linear
structure with a well-defined ordering. But iterators can be used with others kinds of structures
as well, like trees, grids, and graphs. It may be less clear what iteration order to use for
these structures—in some cases, there may be more than one! But we can still implement iterators
for any structure that we can define some type of traversal over.</p>

<p>Let’s consider a relatively simple example of this. We’ve been working with PNGs a lot this semester,
and a pretty common task is iterating over all of the pixels in a <code class="highlighter-rouge">PNG</code> object. Let’s think about how
we could use iterators to make this easier.</p>

<p>First, we can define some iteration order over the PNG. If our only goal is simply to iterate over every
pixel, the order in which we visit pixels doesn’t really matter. We could scan row-first, column-first,
or even visit the pixels randomly. To make things simple, let’s scan row-first. That is, we visit the
coordinates <code class="highlighter-rouge">(0, 0)</code>, <code class="highlighter-rouge">(1, 0)</code>, <code class="highlighter-rouge">(2, 0)</code>, …, <code class="highlighter-rouge">(0, 1)</code>, <code class="highlighter-rouge">(1, 1)</code>, …, and so on.</p>

<p><img src="../../assets/notes/iterators/grid1.png" class="img-fluid d-block mx-auto" style="max-width: 300px;" /></p>

<p>Notice something interesting—unlike with an array, we don’t have a very obvious way to define what the
“one-past-the-end” position is. And that’s OK! That position doesn’t have to correspond with an actual
element or position in the container. Rather, the semantics just have to be that once we advance an
iterator past the last element in the container, the iterator is then “equal” to the end iterator. So,
we can define our end iterator to be some abstract position that’s not on the image grid itself.</p>

<p><img src="../../assets/notes/iterators/grid2.png" class="img-fluid d-block mx-auto" style="max-width: 300px;" /></p>

<p>We’re starting with the iterator pointing at the first position. Let’s advance it one position.</p>

<p><img src="../../assets/notes/iterators/grid3.png" class="img-fluid d-block mx-auto" style="max-width: 300px;" /></p>

<p>If we advance a few more time, we’ll end up on the first column of the second row of the image.</p>

<p><img src="../../assets/notes/iterators/grid4.png" class="img-fluid d-block mx-auto" style="max-width: 300px;" /></p>

<p>If we keep going, we’ll end up at the last valid coordinate on the image.</p>

<p><img src="../../assets/notes/iterators/grid5.png" class="img-fluid d-block mx-auto" style="max-width: 300px;" /></p>

<p>If we try to advance one more time, our iterator will end up at our “one-past-the-end” iterator.</p>

<p><img src="../../assets/notes/iterators/grid6.png" class="img-fluid d-block mx-auto" style="max-width: 300px;" /></p>

<p>At this point, we can’t advance any more, so we’re done!</p>

<p>We can imagine extending the <code class="highlighter-rouge">PNG</code> class to support iterators. To do so,
we’d need to add <code class="highlighter-rouge">begin()</code> and <code class="highlighter-rouge">end()</code> methods. We’d also need to define a custom iterator with
the following properties:</p>

<ul>
  <li><code class="highlighter-rouge">operator++</code> would advance to the coordinates of the next pixel or to the special “one-past-the-end” state</li>
  <li><code class="highlighter-rouge">operator*</code> would return a reference to the <code class="highlighter-rouge">HSLAPixel</code> at the current position</li>
  <li><code class="highlighter-rouge">operator!=</code> would check if two iterators are at the same position and return <code class="highlighter-rouge">false</code> when the
iterator reaches the <code class="highlighter-rouge">end()</code> iterator</li>
</ul>

<p>We won’t go into the details of how such an implementation of would work here.
However, we can see how it could be used to improve our code.</p>

<p>For example, consider this function that transforms a PNG to grayscale:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">grayscale</span><span class="p">(</span><span class="n">cs225</span><span class="o">::</span><span class="n">PNG</span> <span class="o">&amp;</span> <span class="n">png</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">png</span><span class="p">.</span><span class="n">width</span><span class="p">();</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">png</span><span class="p">.</span><span class="n">height</span><span class="p">();</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cs225</span><span class="o">::</span><span class="n">HSLAPixel</span> <span class="o">&amp;</span> <span class="n">pixel</span> <span class="o">=</span> <span class="n">png</span><span class="p">.</span><span class="n">getPixel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
      <span class="n">pixel</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>  
<span class="p">}</span>
</code></pre></div></div>

<p>With our newly-upgraded <code class="highlighter-rouge">PNG</code> class, we could rewrite this to use an iterator:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">grayscale</span><span class="p">(</span><span class="n">PNG</span> <span class="o">&amp;</span> <span class="n">png</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">PNG</span><span class="o">::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">png</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">png</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span>
    <span class="n">HSLAPixel</span> <span class="o">&amp;</span> <span class="n">pixel</span> <span class="o">=</span> <span class="o">*</span><span class="n">it</span><span class="p">;</span>
    <span class="n">pixel</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>  
<span class="p">}</span>
</code></pre></div></div>

<p>Or, better yet, we could use a range-based for loop:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">grayscale</span><span class="p">(</span><span class="n">PNG</span> <span class="o">&amp;</span> <span class="n">png</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">HSLAPixel</span> <span class="o">&amp;</span> <span class="n">pixel</span> <span class="o">:</span> <span class="n">png</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pixel</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>  
<span class="p">}</span>
</code></pre></div></div>

</article>

</body>

<!-- Mirrored from courses.engr.illinois.edu/cs225/sp2019/notes/iterators/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 09 May 2019 18:19:30 GMT -->
</html>
