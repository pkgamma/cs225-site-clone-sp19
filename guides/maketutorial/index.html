<!DOCTYPE html>
<html lang="en">


<!-- Mirrored from courses.engr.illinois.edu/cs225/sp2019/guides/maketutorial/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 09 May 2019 18:19:30 GMT -->
<head>
    <meta charset="UTF-8">
    <title>CS 225 | Makefile Tutorial</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="base_url" content="/cs225/sp2019">

    <link rel="apple-touch-icon" sizes="57x57" href="../../static/img/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="../../static/img/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="../../static/img/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="../../static/img/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="../../static/img/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="../../static/img/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="../../static/img/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="../../static/img/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="../../static/img/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="../../static/img/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="../../static/img/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="../../static/img/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="../../static/img/favicon-16x16.png">
<link rel="manifest" href="../../static/img/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="../../static/img/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">


    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.css">

<link rel="stylesheet" href="../../static/css/main.css">
<link rel="stylesheet" href="../../static/css/github-highlighting.css">

<script src="https://code.jquery.com/jquery-3.4.0.min.js" integrity="sha256-BJeo0qm959uMBGb65z40ejJYGSgR7REI4+CW1fNKwOg=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
<script src="https://cdn.rawgit.com/afeld/bootstrap-toc/v1.0.1/dist/bootstrap-toc.min.js"></script>
<script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" defer></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
            TeX: {
                extensions: [ "AMSmath.js", "AMSsymbols.js" ]
            },
            tex2jax: {
                inlineMath: [['\\(','\\)'], ['$$','$$']],
                displayMath: [['\\[','\\]']]
            },
        });
</script>

<style>
    svg.graph {
        overflow: visible;
        margin-left: auto;
        margin-right: auto;
        margin-bottom: 10px;
        display: block;
        max-width: 95%;
    }
</style>

<style>
  /* Main items  */
  .main-item {
    border-top-left-radius: calc(1rem - 1px);
    border-top-right-radius: calc(1rem - 1px);
    border-bottom-left-radius: calc(1rem - 1px);
    border-bottom-right-radius: calc(1rem - 1px);
    background-size: cover;
    padding: 10px
  }

  .main-item-mp {
    background-image: url('../../assets/covers/default_mp.svg')
  }

  .main-item-lab {
    background-image: url('../../assets/covers/default_lab.svg')
  }

  .main-item-note {
    background-image: url('../../assets/covers/notes.svg')
  }

  .main-item-body {
    width: 320px;
    height: 180px;
    padding: 20px;

    display: flex;
    border: none !important;
    flex-direction: column;
    justify-content: center;
    background-color: rgba(255, 255, 255, 0.91) !important;
  }

  .main-item-body:hover {
    background-color: rgba(255, 255, 255, 0) !important;
    background: transparent;
    border: transparent;
  }

  .main-item-body:hover * {
    -webkit-text-fill-color: white !important;
    -webkit-background-clip: none !important;
  }

  .main-item-text {
    -webkit-text-fill-color: transparent;
    -webkit-background-clip: text;
    background-size: cover;
  }

  .main-item-text-mp {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/default_mp.svg')
  }

  .main-item-text-lab {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/default_lab.svg')
  }

  .main-item-text-note {
    background-image: linear-gradient( rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5) ), url('../../assets/covers/notes.svg')
  }
</style>

</head>
<body class="mb-3">
<nav class="navbar navbar-expand-md navbar-dark bg-dark">
    <a class="navbar-brand mr-0 mr-md-2" href="../../index.html">
        <img src="../../static/img/UIUC_logo.png" alt="UIUC Logo" width="24" height="32" class="d-inline-block align-top mr-2">
        CS 225
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbar">
        <ul class="navbar-nav mr-auto">
            <li class="nav-item ">
                <a class="nav-link" href="../../pages/lectures.html">Lectures</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../assignments/index.html">Assignments</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../exams/index.html">Exams</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../notes/index.html">Notes</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../pages/resources.html">Resources</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" href="../../pages/course_info.html">Course Info</a>
            </li>
        </ul>
    </div>
</nav>

<article class="container py-4">
    <a href="../../pages/resources.html">Back to Guides</a>
    <h1 id="makefile-tutorial">Makefile Tutorial</h1>

<p>In this tutorial, you will:</p>

<ul>
  <li>learn about the basics on compiling C++</li>
  <li>learn how to write a simple makefile</li>
</ul>

<h2 id="a-short-aside-on-compilers">A short aside on compilers</h2>

<p>In this class, we’re hoping to use (at least mainly) the clang C++ compiler.
Clang is a compiler frontend based on LLVM, a project based here at UIUC, and
is generally considered more modern (and informative), while being a mostly
drop-in replacement for gcc. It provides the default C/C++ compiler on systems
designed by Apple, and is becoming increasingly more popular for both
industrial and common use. In previous semesters, we taught this course using
exclusively the gcc C++ compiler. This tutorial will be executed chiefly using
clang, and you are encouraged to follow suit. However, the alternative gcc
command will be provided as well, for historical reasons and your interest.</p>

<p>Take note of the difference between a compiler and the language itself—a
language is a standard, and a compiler interprets according to an
implementation of that standard. (Fun fact: Neither the gcc C++ compiler nor
the clang C++ compiler are actually C++ standard compliant.) In practice in
this class, the differences should not overly concern you. However, if you run
two of the clang/gcc paired commands below, such as the one which invokes their
respective preprocessors, you may find that they do in fact have different
internal behaviour.</p>

<h2 id="introduction-to-compilation">Introduction to compilation</h2>

<p>From your CS 225 git directory, run the following on EWS:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git fetch release
git merge release/maketutorial <span class="nt">-m</span> <span class="s2">"Merging initial maketutorial files"</span>
<span class="nb">cd </span>maketutorial/hello
</code></pre></div></div>

<p>If you’re on your own machine, you may need to run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git fetch release
git merge <span class="nt">--allow-unrelated-histories</span> release/maketutorial <span class="nt">-m</span> <span class="s2">"Merging initial maketutorial files"</span>
<span class="nb">cd </span>maketutorial/hello
</code></pre></div></div>

<p>(Make sure you’ve followed the directions on the <a href="#">Course Setup</a> page to
check out your GitHub repository first.)</p>

<p>Open up the file <code class="highlighter-rouge">hello_world.cpp</code> in your favourite text editor, and let’s
walk through what it’s doing.</p>

<ul>
  <li>The first line includes the library <code class="highlighter-rouge">iostream</code>, the standard input/output
(i/o) streams library. It’s not important that you understand it intimately,
but you’ll use it a lot in the near future. More relevantly, it’s useful for
the upcoming educational example on running the macro preprocessor.</li>
  <li>Next, on line 3, we’re defining a function called <code class="highlighter-rouge">main</code> that returns an
<code class="highlighter-rouge">int</code> (in <code class="highlighter-rouge">main</code>’s case, that’s a return code that usually indicates if the
run was successful; we didn’t write a <code class="highlighter-rouge">return</code> statement, but in this case,
the <code class="highlighter-rouge">return</code> is implicit), and takes no parameters (the empty parens).</li>
  <li>On line 4, there’s a helpful and informative one-line comment.</li>
  <li>Line 5 is the line that actually does the work. <code class="highlighter-rouge">std::cout</code> is a function
from the library <code class="highlighter-rouge">iostream</code> that allows us to print something to the standard
out stream. <code class="highlighter-rouge">&lt;&lt;</code> is the insertion operator (you’ll learn more about operators
later; all you need to know now is that this is print statement syntax), and
the string after that is what we’re printing to standard out.</li>
</ul>

<p>All in all, a very bare-bones Hello, world implementation.</p>

<p>Let’s try compiling it manually:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang++ hello_world.cpp <span class="nt">-o</span> hello
</code></pre></div></div>

<p>or (note that the syntax is the same):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ hello_world.cpp <span class="nt">-o</span> hello
</code></pre></div></div>

<p>The <code class="highlighter-rouge">-o</code> flag tells the compiler to give the executable an alternative name. Otherwise, the default name is <code class="highlighter-rouge">a.out</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./hello
</code></pre></div></div>

<p>The <code class="highlighter-rouge">./</code> simply tells your shell to search the current directory for the
executable, rather than its normal executable paths. If all goes well, you
should see <code class="highlighter-rouge">Hello, world!</code> printed as output. But now let’s try to get a little
more in-depth. You can get rid of the executable you made by typing:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rm </span>hello
</code></pre></div></div>

<p>And an</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span>
</code></pre></div></div>

<p>should verify its disappearance. Run the following command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang++ <span class="nt">-save-temps</span> hello_world.cpp <span class="nt">-o</span> hello
</code></pre></div></div>

<p>or:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-save-temps</span> hello_world.cpp <span class="nt">-o</span> hello
</code></pre></div></div>

<p>The flag <code class="highlighter-rouge">-save-temps</code> tells the compiler to retain the temporary files it
makes when we compile our program… so we can look at them! Listing the
contents of your current directory should yield four new files: naturally the
executable <code class="highlighter-rouge">hello</code>, but also <code class="highlighter-rouge">hello_world.ii</code>, <code class="highlighter-rouge">hello_world.s</code>, and
<code class="highlighter-rouge">hello_world.o</code>, the temporary files we asked the compiler to save, and our
guides into the slightly more technical aspects of basic compilation.</p>

<h3 id="running-the-macro-preprocessor-what-is-hello_worldii">Running the macro preprocessor: What is <code class="highlighter-rouge">hello_world.ii</code>?</h3>

<p>Run the following line:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang++ <span class="nt">-E</span> hello_world.cpp <span class="nt">-o</span> preprocessed.ii
</code></pre></div></div>

<p>or</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-E</span> hello_world.cpp <span class="nt">-o</span> preprocessed.ii
</code></pre></div></div>

<p>Then:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>preprocessed.ii
</code></pre></div></div>

<p>If all goes well, your terminal will spit out a large amount of somewhat
unintelligible code, but at the bottom, there’s the code for our Hello, world
program (with the comment stripped out). So what did the preprocessor do?</p>

<p>All it really did for this program was replace our “include” directive
(<code class="highlighter-rouge">#include &lt;iostream&gt;</code>) with the actual text of the library we included (and, of
course, strip the comment out).</p>

<p>What does that actually mean? Well, if you were capable of compiling this
program at all, somewhere on the machine (be it virtual, remote, or physically
present) that compiled it, there exists a file called <code class="highlighter-rouge">iostream</code>, which
contains the C++ code that implements the i/o streams library. If you were
using clang, it will be located in the directory where the library libc++
(libcxx) is installed. If you were using gcc, it’s in the directory where
libstdc++ (libstdcxx) is installed. Don’t worry about the specific libraries,
it doesn’t really matter, but if you were so inclined, you would be able to
find the code on your own machine. There is no magic involved here.</p>

<p>Back to the preprocessed code. In this case, the only included library was
<code class="highlighter-rouge">iostream</code>, but it would do exactly the same thing for any other included
library. If you had a million include directives, it would go through those
millions of lines, find each file you referenced, and tack it to your program,
so that when you referenced a function or class defined in one of those
standard library files, it would make sense to the compiler—like <code class="highlighter-rouge">std::cout</code>
in this case, which is a function defined in <code class="highlighter-rouge">iostream</code>, that you wouldn’t have
been able to use without including the code. Of course the preprocessor has
plenty of other jobs as well, but we won’t cover them now.</p>

<p>Question: Why did we enclose the library name, <code class="highlighter-rouge">iostream</code>, in angle brackets?
It’s not just so our code looks cooler—we could have said <code class="highlighter-rouge">#include
"iostream"</code> too (feel free to try it out), so what’s the difference? The
difference (in clang and gcc) is that using angle brackets specifies that the
preprocessor should look in the standard compiler include paths, and quotes
tell it to search the current directory first, and via the standard paths only
if that fails. Note that the true standard definition is a little more
complicated than this: technically, both behave in an “implementation-defined
manner” (any implementation could treat that differently if it so wished) but
that’s not very important for us.</p>

<p>Now you can run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>hello_world.ii
</code></pre></div></div>

<p>Look familiar? That’s the output file the preprocessor dumped, and it is
identical to the output you saw when you ran the preprocessor yourself. This is
the file that the compiler really compiles—not your plain, unpreprocessed
source file.</p>

<p>If you want to be sure, try running:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diff hello_world.ii preprocessed.ii
</code></pre></div></div>

<p><code class="highlighter-rouge">diff</code> returns no output if the files it’s comparing are identical. Make sure
that both <code class="highlighter-rouge">hello_world.ii</code> and <code class="highlighter-rouge">preprocessed.ii</code> were produced by the same
compiler, though!</p>

<h3 id="the-actual-compilation-step-what-is-hello_worlds">The actual compilation step: What is <code class="highlighter-rouge">hello_world.s</code>?</h3>

<p>Now let’s take a look at the next temporary file. Print the contents of <code class="highlighter-rouge">hello_world.s</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>hello_world.s
</code></pre></div></div>

<p>For those of you who have seen assembly code before, the output should be
recognisable. If you haven’t, assembly is the low-level intermediate between
normal, higher-level programming languages like C++, and the machine code that
your computer actually executes. In this case, the compiler (this is the step
of compilation that’s actually called compilation) has translated the
preprocessed source code from C++ to assembly, and dumped the output as
<code class="highlighter-rouge">hello_world.s</code>. Let’s ask our compiler to directly compile the code that we
preprocessed into assembly code:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang++ <span class="nt">-S</span> preprocessed.ii <span class="nt">-o</span> compiled.s
</code></pre></div></div>

<p>or</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-S</span> preprocessed.ii <span class="nt">-o</span> compiled.s
</code></pre></div></div>

<p>Use <code class="highlighter-rouge">diff</code> to verify that the files are the same (again, remember to make sure
that both <code class="highlighter-rouge">hello_world.s</code> and <code class="highlighter-rouge">compiled.s</code> were produced by the same compiler):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>diff hello_world.s compiled.s
</code></pre></div></div>

<p>If you used gcc, there shouldn’t be any differences. With clang, the only line
that should be different is a line stating what preprocessed file the assembly
was generated from.</p>

<p>Question: Why don’t we just write everything in assembly language? Well, for
one, it’s kind of annoying to write all the time, and higher level ideas are
harder to keep abstract without our human-friendly programming languages.
Perhaps more importantly, assembly isn’t portable in the slightest. Assembly
languages are specific to a specific architecture, so what assembles and runs
on my machine may not run without alteration on yours. That’s pretty annoying,
and compilers work pretty well, so most people normally leave the assembly to
them.</p>

<h3 id="assembly-what-is-hello_worldo">Assembly: What is <code class="highlighter-rouge">hello_world.o</code>?</h3>

<p>The next step is assembling the code—that just means translating the assembly
code from <code class="highlighter-rouge">hello_world.s</code> into machine-readable code. That’s known as object
code, and the standard suffix for object code is <code class="highlighter-rouge">.o</code>—and unlike <code class="highlighter-rouge">.s</code>, you’re
likely to see quite a few <code class="highlighter-rouge">.o</code> files as you continue in this course. That doesn’t
mean you have to read them, though. If you:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>hello_world.o
</code></pre></div></div>

<p>you’ll fast realise it would be a somewhat unrealistic expectation anyway.</p>

<p>If you want to ask your compiler to assemble your assembly code, you can do
this:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang++ <span class="nt">-c</span> compiled.s <span class="nt">-o</span> assembled.o
</code></pre></div></div>

<p>or</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-c</span> compiled.s <span class="nt">-o</span> assembled.o
</code></pre></div></div>

<h3 id="linking-generating-the-final-executable">Linking: Generating the final executable.</h3>

<p>Linking is the final step, and arguably the most important and relevant to you.
It’s the part you’ll interact with most, and besides perhaps flat out failure
to compile at all, it’s the part of compiling you’ll be most confused by,
particularly at the beginning of this class, when you’re responsible for all of
your own compilation. Linking problems are some of the most notorious issues
people have early on in this class… so pay attention to it, and perhaps you
will be spared the “undefined reference” trauma.</p>

<div class="alert alert-success" role="alert">
  <p><i class="fa fa-location-arrow"></i> 
<strong>Hint for the future</strong>
“Undefined reference” errors are pretty much always linking errors, and you
will probably have them. Remember this.</p>
</div>

<p>All a linker does is take all the object files tossed out by the assembling
step, and join them together into a single executable—in this case, the file
<code class="highlighter-rouge">hello</code> which you ran earlier. We only have one object file in our Hello, world
program, so this linking process is very uninteresting, but very soon (like,
later in this tutorial), you’ll be dealing with multiple object files.</p>

<p>Run the following, to have our compiler link our object file and output our
final executable, <code class="highlighter-rouge">hello_manual</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang++ assembled.o <span class="nt">-o</span> hello_manual
</code></pre></div></div>

<p>or</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ assembled.o <span class="nt">-o</span> hello_manual
</code></pre></div></div>

<p>Feel free to verify that it does exactly the same thing as our original
executable, <code class="highlighter-rouge">hello</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./hello_manual
./hello
</code></pre></div></div>

<p>Congratulations, you’ve just compiled your own miniature program!</p>

<h2 id="dealing-with-multiple-object-files">Dealing with multiple object files</h2>

<p>Let’s visit the example directory <code class="highlighter-rouge">animals</code> now.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ../animals/
<span class="nb">ls</span>
</code></pre></div></div>

<p>The files you’ll see listed are <code class="highlighter-rouge">dog.hpp</code>, <code class="highlighter-rouge">dog.cpp</code>, and <code class="highlighter-rouge">main.cpp</code>. Feel free
to check out the source code. <code class="highlighter-rouge">dog.hpp</code> is a C++ header file, what we’d call
the definition of the <code class="highlighter-rouge">Dog</code> class, and <code class="highlighter-rouge">dog.cpp</code> is a source file, the
implementation for said class. You’ll become more familiar with the details of
that relationship as the class moves on, but right now, just know that
together, they make the <code class="highlighter-rouge">Dog</code> class. <code class="highlighter-rouge">main.cpp</code> might look more familiar to
you.  It’s a lot like <code class="highlighter-rouge">hello_world.cpp</code> from the last exercise, in that it has
some includes and it has an executable <code class="highlighter-rouge">main</code> function. In that <code class="highlighter-rouge">main</code>
function, it calls a constructor for the class <code class="highlighter-rouge">Dog</code>, and asks the object it
creates to do a number of things. But including the <code class="highlighter-rouge">Dog</code> header file doesn’t
actually make the source code available. First, compile the main object file:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang++ <span class="nt">-c</span> main.cpp <span class="nt">-o</span> main.o
</code></pre></div></div>

<p>or</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-c</span> main.cpp <span class="nt">-o</span> main.o
</code></pre></div></div>

<p>Then, try compiling <code class="highlighter-rouge">dog_program</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang++ main.o <span class="nt">-o</span> dog_program
</code></pre></div></div>

<p>or</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ main.o <span class="nt">-o</span> dog_program
</code></pre></div></div>

<p>That’s what we did before for our Hello, world program, so what happened this
time? You got a bunch of “undefined reference” errors, and if you remember what
we said a few paragraphs up, “undefined reference” errors are pretty much
always linking errors. The compiler’s telling us that it doesn’t know what the
function <code class="highlighter-rouge">Dog::bark()</code> (or any <code class="highlighter-rouge">Dog</code> function) does, because it doesn’t have
that information in <code class="highlighter-rouge">main.cpp</code>. The solution is to compile a separate object
file for the <code class="highlighter-rouge">Dog</code> class. In general, you’ll have one object file per <code class="highlighter-rouge">.cpp</code>
source file, compiled together with its header file (<code class="highlighter-rouge">.h</code> or <code class="highlighter-rouge">.hpp</code>) and other
necessary dependencies. So let’s compile an object file for the <code class="highlighter-rouge">Dog</code> class.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang++ <span class="nt">-c</span> dog.cpp
</code></pre></div></div>

<p>or</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-c</span> dog.cpp
</code></pre></div></div>

<p>And then:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">ls</span>
</code></pre></div></div>

<p>You’ll see that it added a new file called <code class="highlighter-rouge">dog.o</code>, the object file for the
<code class="highlighter-rouge">Dog</code> class (if you include the header in the compilation, you’ll also see a
<code class="highlighter-rouge">.h.gch</code> or <code class="highlighter-rouge">.hpp.gch</code> file. The <code class="highlighter-rouge">.gch</code> file is a precompiled header; all that
happens with that is in the future, for fulfilling an <code class="highlighter-rouge">#include "dog.hpp"</code>
directive, the precompiled header is preferentially used). So now if we wanted
to compile these together, we would do this:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang++ dog.o main.o <span class="nt">-o</span> dog_program
</code></pre></div></div>

<p>or</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ dog.o main.o <span class="nt">-o</span> dog_program
</code></pre></div></div>

<p>And that should complete just fine. Try running it like so:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./dog_program
</code></pre></div></div>

<p>But what happens if we change something? If we just change something in
<code class="highlighter-rouge">main.cpp</code>, like the <code class="highlighter-rouge">Dog</code>’s name, we just have to run that final linking
command again, and that’s easy. But if we change something in the <code class="highlighter-rouge">Dog</code> class
itself, like adding a new function, or changing an implementation, we have to
recompile the <code class="highlighter-rouge">Dog</code> object file, and then link it back to the main object file.
That may not seem like a big deal now, but it gets annoying extremely fast when
you have more than a single tiny class.</p>

<h2 id="introducing-the-program-make">Introducing the program <code class="highlighter-rouge">make</code></h2>

<p>Those of you with some experience in compilation are probably aware of a common
Unix utility called <code class="highlighter-rouge">make</code>. It’s a program extremely widely used on Unix based
systems (Microsoft also has a Visual Studio spinoff called <code class="highlighter-rouge">nmake</code>), generally
to build executable program files from source files. (Don’t let the “expected
use” case fool you, though—<code class="highlighter-rouge">make</code> is not a program limited by the narrow
realm of compilation, as you’ll see before this tutorial is over.)</p>

<p>The best instruction is by example, so let’s build a basic <code class="highlighter-rouge">Makefile</code> for our
<code class="highlighter-rouge">dog_program</code>. Open a file called <code class="highlighter-rouge">Makefile</code> (make sure it’s titlecase—<code class="highlighter-rouge">make</code>
will recognise the lowercase <code class="highlighter-rouge">makefile</code> as well, but our autograder won’t, so
it’s good to get into the habit now) with your preferred text editor (mine is
emacs, yours may not be, so replace “emacs” with your editor of choice if you
disagree):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>emacs Makefile
</code></pre></div></div>

<p>Note that you won’t see the new file in your directory until you save it.</p>

<p>Makefile rules are written in the format:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">target </span><span class="o">:</span> <span class="nf">tgt_dependency1 tgt_dependency2 ...</span>
	<span class="nb">command</span>
</code></pre></div></div>

<p>So if our target is <code class="highlighter-rouge">dog.o</code>, what are the dependencies (the files needed to make
the target)? They’re <code class="highlighter-rouge">dog.cpp</code> and <code class="highlighter-rouge">dog.hpp</code>, of course. And the command is the
same as the one we used to compile the object file to begin with. So our rule
for <code class="highlighter-rouge">dog.o</code>, the dog object file, will look like this:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">dog.o </span><span class="o">:</span> <span class="nf">dog.cpp dog.hpp</span>
	clang++ <span class="nt">-c</span> dog.cpp
</code></pre></div></div>

<p>Copy that into your new <code class="highlighter-rouge">Makefile</code>, and save it (for the makefile examples, I
won’t explicitly give you the gcc equivalents, but if you want to use gcc
instead, just replace all references to clang++ with g++). Now let’s write a
rule for <code class="highlighter-rouge">main.o</code>:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">main.o </span><span class="o">:</span> <span class="nf">main.cpp</span>
	clang++ <span class="nt">-c</span> main.cpp
</code></pre></div></div>

<div class="alert alert-success" role="alert">
  <p><i class="fa fa-location-arrow"></i> 
<strong>Tabbing in makefiles</strong>
Remember: the tab is very important—if you don’t tab the second line of a
rule, you’ll get the error “<code class="highlighter-rouge">*** missing separator. Stop.</code>” Don’t forget your
tabs!</p>
</div>

<p>You can remove everything in the directory besides <code class="highlighter-rouge">dog.cpp</code>, <code class="highlighter-rouge">dog.hpp</code>,
<code class="highlighter-rouge">main.cpp</code>, and <code class="highlighter-rouge">Makefile</code> for the demonstration to have any real effect, and
then execute <code class="highlighter-rouge">make</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">rm </span>dog.o dog_program
make
</code></pre></div></div>

<p>If you <code class="highlighter-rouge">ls</code> now, you’ll see that it’s built the target <code class="highlighter-rouge">dog.o</code> (and left the
precompiled header as well). But what is <code class="highlighter-rouge">make</code> doing?</p>

<h3 id="an-aside-about-the-order-in-which-make-interprets-makefiles">An aside about the order in which make interprets makefiles</h3>

<p>When called, <code class="highlighter-rouge">make</code> will search the current directory for a file called <code class="highlighter-rouge">Makefile</code>
or <code class="highlighter-rouge">makefile</code> (again, for your sanity and grades, please only use <code class="highlighter-rouge">Makefile</code>,
titlecase, with a capitalised <code class="highlighter-rouge">M</code>). If it finds one, it will execute the first
rule in the file, and if one of the dependencies of the first target does not
yet exist, it will search for a rule that creates it. So for example, if I have
a makefile like so:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">animal_assembly </span><span class="o">:</span> <span class="nf">moose goose cat</span>
	<span class="nb">command</span>
<span class="nl">moose </span><span class="o">:</span> <span class="nf">antlers hooves fur</span>
	<span class="nb">command</span>
<span class="nl">goose </span><span class="o">:</span> <span class="nf">beak wings webbed_feet interest_in_bread</span>
	<span class="nb">command</span>
<span class="nl">cat </span><span class="o">:</span> <span class="nf">whiskers evil_personality</span>
	<span class="nb">command</span>
</code></pre></div></div>

<p>then <code class="highlighter-rouge">make</code>, when called with no arguments, will attempt to build the target
<code class="highlighter-rouge">animal_assembly</code>. Assuming the dependencies <code class="highlighter-rouge">moose</code>, <code class="highlighter-rouge">goose</code>, and <code class="highlighter-rouge">cat</code> are
already available in the directory, it will completely ignore the rules for
them, and build <code class="highlighter-rouge">animal_assembly</code> from what’s present. If <code class="highlighter-rouge">moose</code> and <code class="highlighter-rouge">cat</code> are
available, but <code class="highlighter-rouge">goose</code> is not, it will note that <code class="highlighter-rouge">moose</code> is present, see that
<code class="highlighter-rouge">goose</code> is not present, look for a rule to build <code class="highlighter-rouge">goose</code>, find the rule, build
<code class="highlighter-rouge">goose</code>, and then note that <code class="highlighter-rouge">cat</code> is present and build <code class="highlighter-rouge">animal_assembly</code>. If
none of <code class="highlighter-rouge">moose</code>, <code class="highlighter-rouge">goose</code>, <code class="highlighter-rouge">cat</code> are present, it will have to build all of them
using the rules available.</p>

<p>But what if you put the target for <code class="highlighter-rouge">moose</code> first?</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">moose </span><span class="o">:</span> <span class="nf">antlers hooves fur</span>
	<span class="nb">command</span>
<span class="nl">animal_assembly </span><span class="o">:</span> <span class="nf">moose goose cat</span>
	<span class="nb">command</span>
<span class="nl">goose </span><span class="o">:</span> <span class="nf">beak wings webbed_feet interest_in_bread</span>
	<span class="nb">command</span>
<span class="nl">cat </span><span class="o">:</span> <span class="nf">whiskers evil_personality</span>
	<span class="nb">command</span>
</code></pre></div></div>

<p>Well, then if <code class="highlighter-rouge">make</code> is called with no arguments, it will make the target <code class="highlighter-rouge">moose</code>
and stop. If you wanted it to make <code class="highlighter-rouge">animal_assembly</code>, you would then have to call
it like so:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make animal_assembly
</code></pre></div></div>

<p>So a good rule of thumb is to put the final and most important command (for our
purposes, the one that finally links the object files together into an
executable) at the top.</p>

<p>Now back to our <code class="highlighter-rouge">dog</code> example. For our <code class="highlighter-rouge">dog</code> program, what the above means is
that we should put the rule for the whole program at the top. How should we
write it? Well, perhaps as you’d expect at this point:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">dog_program </span><span class="o">:</span> <span class="nf">dog.o main.o</span>
	clang++ dog.o main.o <span class="nt">-o</span> dog_program
</code></pre></div></div>

<p>Put that at the top of your makefile, save it, and run make again.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make
<span class="nb">ls</span>
</code></pre></div></div>

<p>Now you should see the executable <code class="highlighter-rouge">dog_program</code>, which should behave as it has
in all previous post-compilation incarnations.</p>

<p>Now let’s do one final thing—in general, you should do this when writing your
own <code class="highlighter-rouge">Makefile</code>s, but it’s especially useful for instructive purposes: we’ll
write a <code class="highlighter-rouge">clean</code> rule.</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">clean </span><span class="o">:</span>
	<span class="nb">rm </span>dog_program <span class="k">*</span>.o
</code></pre></div></div>

<p>Add that to the bottom of your <code class="highlighter-rouge">Makefile</code> (as long as it’s not the top, it
doesn’t really matter, but in long <code class="highlighter-rouge">Makefile</code>s, you want to separate the
<code class="highlighter-rouge">clean</code> targets from real compilation-relevant targets for clarity), save it,
and run <code class="highlighter-rouge">make</code> again, passing <code class="highlighter-rouge">clean</code> as an argument to invoke the <code class="highlighter-rouge">clean</code> rule:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make clean
<span class="nb">ls</span>
</code></pre></div></div>

<p>What happened? We’ve deleted all of the executables and compilation byproducts
that we created, to clean up the directory. But the most notable thing about
this rule compared to the others we’ve seen is that it a.) lacks dependencies
and b.) doesn’t perform anything compilation-related in its command. Let’s talk
about those two things a bit.</p>

<h3 id="the-dependency-list">The dependency list</h3>

<p>The dependency list you write for a target exists so that <code class="highlighter-rouge">make</code> knows what
other targets to ensure you have before you run the command, but if the targets
are guaranteed to be present and <code class="highlighter-rouge">make</code> isn’t responsible for updating them,
<code class="highlighter-rouge">make</code> technically doesn’t need to check for anything. (It does not parse the
actual command you give it, so it will not know what files to look for based on
that.) Try deleting the dependency list of the target <code class="highlighter-rouge">dog.o</code>, and then
running:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make clean
make dog.o
</code></pre></div></div>

<p>Since <code class="highlighter-rouge">dog.cpp</code> and <code class="highlighter-rouge">dog.hpp</code> are present in the directory, and <code class="highlighter-rouge">make</code> doesn’t have
to rebuild them individually when they change (as it does for <code class="highlighter-rouge">dog.o</code>), <code class="highlighter-rouge">make</code> will
have never have errors when compiling that line. But if you deleted the
dependency list for the target <code class="highlighter-rouge">dog_program</code> and ran:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make clean
make
</code></pre></div></div>

<p><code class="highlighter-rouge">make</code> will output an error that the <code class="highlighter-rouge">recipe for target 'dog_program' failed</code>,
because <code class="highlighter-rouge">dog.o</code> was not in the dependency list, and <code class="highlighter-rouge">make</code> therefore did not
check to make sure it existed. As such, it didn’t bother to build it. As for
including dependencies that make will never have to build (such as <code class="highlighter-rouge">.h</code>/<code class="highlighter-rouge">.hpp</code>
and <code class="highlighter-rouge">.cpp</code> files), well, it’s simply good practice to document the dependencies
of each target thoroughly. It’s cleaner for other people to read, and it’s a
good way for you to confirm that you’re doing what you wanted to do,
particularly late at night when the lines start to blur together. And now onto
point B.</p>

<h3 id="make-will-run-anything-you-ask-it-to-because-its-not-as-smart-as-you-think-it-is"><code class="highlighter-rouge">make</code> will run anything you ask it to, because it’s not as smart as you think it is</h3>

<p>This is what we were referring to earlier, when we said <code class="highlighter-rouge">make</code> was not limited
to compilation-related commands. Let’s move over to a different directory, for
some <code class="highlighter-rouge">make</code>-related messing about.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ../file_meddling/
<span class="nb">ls</span>
</code></pre></div></div>

<p>As you can see, the <code class="highlighter-rouge">Makefile</code> is currently the only thing in this directory.
It’s a very small and simple one, so open it up with your favourite text
editor, and try guessing what it will do. It’s not compilation—it’s something
altogether much sillier. When you have your prediction, execute <code class="highlighter-rouge">make</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make
<span class="nb">ls</span>
</code></pre></div></div>

<p>And now there’s a new file in the directory. The command</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat </span>silly_file
</code></pre></div></div>

<p>will yield the somewhat accurate phrase “Hello, there is nothing important
here”—I say somewhat because while the file and indeed the phrase itself are
completely unimportant, the concept is, in fact, important. <code class="highlighter-rouge">make</code> is not a
magical program that intuits the mysterious delicacies of compilation by
parsing incomprehensible syntax and making anything more of it than what you
yourself put there. <code class="highlighter-rouge">make</code> is simply executing the command you gave it, and it
does so blindly, and without any particular personal interest in the results.
Feel free to execute the following now:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make move_file
<span class="nb">ls</span>
</code></pre></div></div>

<p>Now, when make executes the rule for the target <code class="highlighter-rouge">move_file</code>, it simply renames
the file <code class="highlighter-rouge">silly_file</code> to something even more ungainly. And finally:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make delete_file
<span class="nb">ls</span>
</code></pre></div></div>

<p>removes the file altogether. Usually a rule like this will be named <code class="highlighter-rouge">clean</code>,
and it’s very acceptable to stick to that convention for the rest of your life.
However to illustrate that there is nothing magical about the target name
<code class="highlighter-rouge">clean</code> (or indeed, any target name at all), in this <code class="highlighter-rouge">Makefile</code>, we are using the
<code class="highlighter-rouge">clean</code> target to populate our directory with junk. Try it:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make clean
<span class="nb">ls</span>
</code></pre></div></div>

<p>Note that there are now five empty junk files (the directory is not cleaner),
and feel free to remove them:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make really_clean
</code></pre></div></div>

<p>(For the future, it is recommended that this educational example not be taken
too deeply to heart. Conventions exist for a reason, and that reason is usually
to make everybody’s lives easier. It is always worth knowing, though, that
conventions are ultimately just that—conventions.)</p>

<p>Another important concept is understanding the control flow. In what order
would the commands have to have gone in order to create a new file and fill it
with text? Cheerfully, <code class="highlighter-rouge">make</code> will tell you what command it’s executing as it
executes them, but don’t take that for granted. Walk through the <code class="highlighter-rouge">Makefile</code>
yourself. In fact, let’s do it together.</p>

<p>The first rule you hit is the rule for the target <code class="highlighter-rouge">all</code>. all is a phony target,
commonly used both in the real world and in CS225, placed at the top of a
<code class="highlighter-rouge">Makefile</code>, which, in its typical use case, will list all relevant targets
which produce executables as dependencies. This ensures that <code class="highlighter-rouge">make</code> will
compile all of the executables for which there are rules listed. In this case,
we’ve just put it at the top because we can. It, of course, is not currently
responsible for any executables.</p>

<p>When you read the rule for all, you see the dependency listed is
<code class="highlighter-rouge">fill_file_with_nonsense</code>. Obviously <code class="highlighter-rouge">fill_file_with_nonsense</code> doesn’t actually
exist in the directory, so we skip down to the rule for
<code class="highlighter-rouge">fill_file_with_nonsense</code>. The dependency listed is <code class="highlighter-rouge">create_file</code>, which also
isn’t a real file, so we skip to the rule for <code class="highlighter-rouge">create_file</code>, which tells us it
has no dependencies, and to <code class="highlighter-rouge">touch silly_file</code>. <code class="highlighter-rouge">touch</code> is a standard Unix
program that can create, as we have done here, an empty file.</p>

<p>Once that’s done, we can finish up the rule to “build” <code class="highlighter-rouge">fill_file_with_nonsense</code>,
which pipes the string “Hello, there is nothing important here” into the newly
created file <code class="highlighter-rouge">silly_file</code>.</p>

<p>Then we can finish up “building” the target all, for which the command is to
print the string “I have mostly created a lot of junk today!” to standard out.
And so it does. Take note that, of course, it “builds” none of the targets that
are not present in its direct control flow, so the unmentioned targets have to
be explicitly passes as arguments to <code class="highlighter-rouge">make</code> in order for it to build them.</p>

<p>Just to be really clear, let’s add another rule to our <code class="highlighter-rouge">Makefile</code>. Open the
<code class="highlighter-rouge">Makefile</code> in your text editor of choice, and write the rule <code class="highlighter-rouge">open_file</code>:</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">open_file </span><span class="o">:</span>
	gedit another_silly_file
</code></pre></div></div>

<p>(If you do not have gedit installed, use another text editor.) Now run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make open_file
</code></pre></div></div>

<p>and the gedit text editor will open <code class="highlighter-rouge">another_silly_file</code>. Feel free to make a
little change and run make <code class="highlighter-rouge">open_file</code> again. It will open the same file. And
because of our cleverly repetitive naming scheme, we can even delete it with</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make delete_file
</code></pre></div></div>

<p>So hopefully now the basics are painfully clear. Let’s move on.</p>

<h3 id="marvelous-macros">Marvelous macros</h3>

<p>Now let’s gloss over a basic component of makefile syntax that we’ve so far
neglected to mention. Makefile syntax allows for a certain kind of variable
called a macro. Macros are useful in a standard makefile essentially for the
same reason that variables are useful in a normal program—they allow you to
quickly define parts of your program which will appear repeatedly, and if you
later to decide to change that part of the program, well, it’s a single change,
rather than the countlessly many that are possible in large makefiles. In this
class, you will never actually need macros to write an effective and mostly
unrepetitive makefile, but it’s not a bad habit to get into, so let’s see an
example.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ../macro_intro/
</code></pre></div></div>

<p>You may notice that our Hello, world example from ages ago has returned, and
now we have a makefile for it. Open up the <code class="highlighter-rouge">Makefile</code>. There’s some rather
strange syntax in here, so let’s try to break it down.</p>

<p>First, we’ve defined a macro called <code class="highlighter-rouge">CXX</code>. Unfortunately, this is a special
macro, so we’re going to ignore it briefly and jump to <code class="highlighter-rouge">FLAGS</code>. <code class="highlighter-rouge">FLAGS</code> is a
macro we defined to refer to the flags we’re passing our compiler; in this
case, the flag is <code class="highlighter-rouge">-O</code>, an optimisation option that turns on a series of other
flags which it’s not important for you to know right now (see the clang/gcc
documentation for that information). <code class="highlighter-rouge">FLAGS</code> of course isn’t restricted in
value to valid flags—we could have said <code class="highlighter-rouge">FLAGS = some moose have large
antlers</code> and <code class="highlighter-rouge">make</code> would have been perfectly happy with that, until the call
to clang++ failed later (you can try it out; <code class="highlighter-rouge">make</code> will actually try to
execute <code class="highlighter-rouge">g++ some moose have large antlers hello_world.cpp -o hello</code>).</p>

<p>Now let’s talk about <code class="highlighter-rouge">CXX</code>. Not all macro names in the <code class="highlighter-rouge">Makefile</code> language are
completely without meaning—there is a certain set of names which do have a
default meaning. In this case, we’ve defined <code class="highlighter-rouge">CXX = clang++</code>. The <code class="highlighter-rouge">CXX</code> macro’s
default value is usually <code class="highlighter-rouge">g++</code> on Linux systems, so if we never defined the
macro <code class="highlighter-rouge">CXX</code>, when we used it in the command to compile the executable, it would
have probably used <code class="highlighter-rouge">g++</code> instead. Try running <code class="highlighter-rouge">make</code> right now, and you should
see the following output:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make
clang++ <span class="nt">-O</span> hello_world.cpp <span class="nt">-o</span> hello
</code></pre></div></div>

<p>But if you delete the line that says <code class="highlighter-rouge">CXX = clang++</code>, what happens?</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make
g++ <span class="nt">-O</span> hello_world.cpp <span class="nt">-o</span> hello
</code></pre></div></div>

<p>Feel free to replace the line now.</p>

<p>When you call a macro, enclose it like so: <code class="highlighter-rouge">$(MACRO)</code>. That’s simply makefile
language syntax. (You may have noticed that my example macro’s name was all
uppercase—as in fact, all of my macros thus far have been. This is not
syntactically required, but it is conventional.)</p>

<p>So that explains most of what’s going on in this file, but the strange symbols
<code class="highlighter-rouge">$?</code> and <code class="highlighter-rouge">$@</code> remain, perhaps, mysteries. As you might guess, those are also
macros—they’re special predefined macros in the makefile language, with the
respective meanings “names of the dependencies (newer than the target)” and
“name of the target”, so in this case, <code class="highlighter-rouge">$?</code> refers to <code class="highlighter-rouge">hello_world.cpp</code>
(provided that you <code class="highlighter-rouge">make clean</code> before you <code class="highlighter-rouge">make</code>), and <code class="highlighter-rouge">$@</code> refers to <code class="highlighter-rouge">hello</code>,
incidentally (purposefully) the name of the executable created as well. Using
shorthand like this is a good motivation to name targets after the file the
rule creates (this is, of course, also conventional, and increases the
readability of your <code class="highlighter-rouge">Makefile</code>s drastically). Special predefined macros aren’t
important for you to know—there are others we haven’t yet mentioned—but as
you go about life in CS225 and the real world, you are bound to come across
them.</p>

<h2 id="compiler-and-linker-flags-in-cs225">Compiler and linker flags in CS225</h2>

<p>For this class we are going to have a very standard set of flags to pass during
compilation and linking. We are going to define these as macros in each
assignment’s Makefile. Here is an example of what those look like (taken from
<code class="highlighter-rouge">lab_intro</code>):</p>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># This defines our compiler and linker, as we've seen before.
</span><span class="nv">CXX</span> <span class="o">=</span> clang++
<span class="nv">LD</span> <span class="o">=</span> clang++

<span class="c"># These are the options we pass to the compiler.
# -std=c++1y means we want to use the C++14 standard (called 1y in this version of Clang).
# -stdlib=libc++ specifies that we want to use the standard library implementation called libc++
# -c specifies making an object file, as you saw before
# -g specifies that we want to include "debugging symbols" which allows us to use a debugging program.
# -O0 specifies to do no optimizations on our code.
# -Wall, -Wextra, and -pedantic tells the compiler to look out for common problems with our code. -Werror makes it so that these warnings stop compilation.
</span><span class="nv">CXXFLAGS</span> <span class="o">=</span> <span class="nt">-std</span><span class="o">=</span>c++1y <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-c</span> <span class="nt">-g</span> <span class="nt">-O0</span> <span class="nt">-Wall</span> <span class="nt">-Wextra</span> <span class="nt">-Werror</span> <span class="nt">-pedantic</span>

<span class="c"># These are the options we pass to the linker.
# The first two are the same as the compiler flags.
# -l&lt;something&gt; tells the linker to go look in the system for pre-installed object files to link with.
# Here we want to link with the object files from libpng (since we use it in our code) and libc++. Remember libc++ is the standard library implementation.
</span><span class="nv">LDFLAGS</span> <span class="o">=</span> <span class="nt">-std</span><span class="o">=</span>c++1y <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-lc</span>++abi
</code></pre></div></div>

<h2 id="a-final-diversion-the-makefile-language-is-turing-complete">A final diversion: The makefile language is Turing complete?</h2>

<p>Limited the uses may be for such information, but particularly thanks to its
support for lambda abstractions and combinators, the makefile language is
actually a complete functional programming language. Will you ever need to
write a Fibonacci number generator in the makefile language? Probably not, but
you certainly can.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ../functional_fun/
make
</code></pre></div></div>

<p>This will, of course, get quite slow as <script type="math/tex">n</script> gets large (the naive solution
takes exponential time), so I suggest you stop the process with a well timed
Ctrl-C as it begins to lag.</p>

<h2 id="fin">fin</h2>

<p>That concludes the tutorial on compilation and <code class="highlighter-rouge">Makefile</code>s. If you have any
questions, please feel free to look up the concepts yourself, ask about them
on Piazza, or ask your TAs or classmates for help.</p>

</article>

</body>

<!-- Mirrored from courses.engr.illinois.edu/cs225/sp2019/guides/maketutorial/ by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 09 May 2019 18:19:30 GMT -->
</html>
